diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdacore/v1_0/AwsLambdaRequestHandlerInstrumentation.java b/instrumentation/aws-lambda/aws-lambda-core-1.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdacore/v1_0/AwsLambdaRequestHandlerInstrumentation.java
index 93071e04d2..add9f64276 100644
--- a/instrumentation/aws-lambda/aws-lambda-core-1.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdacore/v1_0/AwsLambdaRequestHandlerInstrumentation.java
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdacore/v1_0/AwsLambdaRequestHandlerInstrumentation.java
@@ -68,7 +68,7 @@ public class AwsLambdaRequestHandlerInstrumentation implements TypeInstrumentati
         @Advice.Local("otelContext") io.opentelemetry.context.Context otelContext,
         @Advice.Local("otelScope") Scope otelScope) {
       input = AwsLambdaRequest.create(context, arg, Collections.emptyMap());
-      io.opentelemetry.context.Context parentContext = functionInstrumenter().extract(input);
+      io.opentelemetry.context.Context parentContext = functionInstrumenter().extract(input, context);
 
       if (!functionInstrumenter().shouldStart(parentContext, input)) {
         return;
diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdacore/v1_0/AwsLambdaRequestStreamHandlerInstrumentation.java b/instrumentation/aws-lambda/aws-lambda-core-1.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdacore/v1_0/AwsLambdaRequestStreamHandlerInstrumentation.java
index a6b89d253d..e62d30eddb 100644
--- a/instrumentation/aws-lambda/aws-lambda-core-1.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdacore/v1_0/AwsLambdaRequestStreamHandlerInstrumentation.java
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdacore/v1_0/AwsLambdaRequestStreamHandlerInstrumentation.java
@@ -69,7 +69,7 @@ public class AwsLambdaRequestStreamHandlerInstrumentation implements TypeInstrum
         @Advice.Local("otelScope") Scope otelScope) {
 
       otelInput = AwsLambdaRequest.create(context, input, Collections.emptyMap());
-      io.opentelemetry.context.Context parentContext = functionInstrumenter().extract(otelInput);
+      io.opentelemetry.context.Context parentContext = functionInstrumenter().extract(otelInput, context);
 
       if (!functionInstrumenter().shouldStart(parentContext, otelInput)) {
         return;
diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/build.gradle.kts b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/build.gradle.kts
index df605add2f..e16c736990 100644
--- a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/build.gradle.kts
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/build.gradle.kts
@@ -5,11 +5,12 @@ plugins {
 dependencies {
   compileOnly("io.opentelemetry:opentelemetry-sdk")
   compileOnly("io.opentelemetry:opentelemetry-sdk-extension-autoconfigure")
+  compileOnly(project(":muzzle"))
 
   compileOnly("com.google.auto.value:auto-value-annotations")
   annotationProcessor("com.google.auto.value:auto-value")
 
-  library("com.amazonaws:aws-lambda-java-core:1.0.0")
+  library("com.amazonaws:aws-lambda-java-core:1.4.0")
 
   // We do lightweight parsing of JSON to extract HTTP headers from requests for propagation.
   // This will be commonly needed even for users that don't use events, but luckily it's not too big.
@@ -26,6 +27,7 @@ dependencies {
 
   testImplementation(project(":instrumentation:aws-lambda:aws-lambda-core-1.0:testing"))
   testImplementation("uk.org.webcompere:system-stubs-jupiter")
+  testImplementation("com.google.guava:guava")
 }
 
 tasks.withType<Test>().configureEach {
diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/TracingRequestHandler.java b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/TracingRequestHandler.java
index 873040f66e..b38648e8cf 100644
--- a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/TracingRequestHandler.java
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/TracingRequestHandler.java
@@ -66,7 +66,7 @@ public abstract class TracingRequestHandler<I, O> implements RequestHandler<I, O
   @Override
   public final O handleRequest(I input, Context context) {
     AwsLambdaRequest request = AwsLambdaRequest.create(context, input, extractHttpHeaders(input));
-    io.opentelemetry.context.Context parentContext = instrumenter.extract(request);
+    io.opentelemetry.context.Context parentContext = instrumenter.extract(request, context);
 
     if (!instrumenter.shouldStart(parentContext, request)) {
       return doHandleRequest(input, context);
diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/TracingRequestStreamHandler.java b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/TracingRequestStreamHandler.java
index ae6a42bd6d..8c3663aedf 100644
--- a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/TracingRequestStreamHandler.java
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/TracingRequestStreamHandler.java
@@ -70,7 +70,7 @@ public abstract class TracingRequestStreamHandler implements RequestStreamHandle
       throws IOException {
     ApiGatewayProxyRequest proxyRequest = ApiGatewayProxyRequest.forStream(input);
     AwsLambdaRequest request = createRequest(input, context, proxyRequest);
-    io.opentelemetry.context.Context parentContext = instrumenter.extract(request);
+    io.opentelemetry.context.Context parentContext = instrumenter.extract(request, context);
 
     if (!instrumenter.shouldStart(parentContext, request)) {
       doHandleRequest(proxyRequest.freshStream(), output, context, request);
diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ApiGatewayProxyRequest.java b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ApiGatewayProxyRequest.java
index 1582ee649e..7e130bd49e 100644
--- a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ApiGatewayProxyRequest.java
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ApiGatewayProxyRequest.java
@@ -30,7 +30,14 @@ public abstract class ApiGatewayProxyRequest {
   private static boolean noHttpPropagationNeeded() {
     Collection<String> fields =
         GlobalOpenTelemetry.getPropagators().getTextMapPropagator().fields();
-    return fields.isEmpty();
+    return fields.isEmpty() || xrayPropagationFieldsOnly(fields);
+  }
+
+  private static boolean xrayPropagationFieldsOnly(Collection<String> fields) {
+    // ugly but faster than typical convert-to-set-and-check-contains-only
+    return (fields.size() == 1)
+        && ParentContextExtractor.AWS_TRACE_HEADER_PROPAGATOR_KEY.equalsIgnoreCase(
+            fields.iterator().next());
   }
 
   public static ApiGatewayProxyRequest forStream(InputStream source) {
diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/AwsLambdaFunctionInstrumenter.java b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/AwsLambdaFunctionInstrumenter.java
index 9341bf6f79..f719c1ea93 100644
--- a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/AwsLambdaFunctionInstrumenter.java
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/AwsLambdaFunctionInstrumenter.java
@@ -12,7 +12,6 @@ import io.opentelemetry.instrumentation.api.instrumenter.Instrumenter;
 import io.opentelemetry.instrumentation.api.internal.ContextPropagationDebug;
 import io.opentelemetry.instrumentation.awslambdacore.v1_0.AwsLambdaRequest;
 import java.util.HashMap;
-import java.util.Locale;
 import java.util.Map;
 import javax.annotation.Nullable;
 
@@ -47,8 +46,8 @@ public class AwsLambdaFunctionInstrumenter {
     instrumenter.end(context, input, response, error);
   }
 
-  public Context extract(AwsLambdaRequest input) {
-    ContextPropagationDebug.debugContextLeakIfEnabled();
+  public Context extract(
+      AwsLambdaRequest input, com.amazonaws.services.lambda.runtime.Context lambdaContext) {
     // Look in both the http headers and the custom client context
     Map<String, String> headers = input.getHeaders();
     if (input.getAwsContext() != null && input.getAwsContext().getClientContext() != null) {
@@ -59,23 +58,15 @@ public class AwsLambdaFunctionInstrumenter {
       }
     }
 
-    return openTelemetry
-        .getPropagators()
-        .getTextMapPropagator()
-        .extract(Context.root(), headers, MapGetter.INSTANCE);
+    return ParentContextExtractor.extract(headers, this, lambdaContext);
   }
 
-  private enum MapGetter implements TextMapGetter<Map<String, String>> {
-    INSTANCE;
-
-    @Override
-    public Iterable<String> keys(Map<String, String> map) {
-      return map.keySet();
-    }
+  public Context extract(Map<String, String> headers, TextMapGetter<Map<String, String>> getter) {
+    ContextPropagationDebug.debugContextLeakIfEnabled();
 
-    @Override
-    public String get(Map<String, String> map, String s) {
-      return map.get(s.toLowerCase(Locale.ROOT));
-    }
+    return openTelemetry
+        .getPropagators()
+        .getTextMapPropagator()
+        .extract(Context.root(), headers, getter);
   }
 }
diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ParentContextExtractor.java b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ParentContextExtractor.java
new file mode 100644
index 0000000000..6349d1bb29
--- /dev/null
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ParentContextExtractor.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awslambdacore.v1_0.internal;
+
+import static io.opentelemetry.instrumentation.awslambdacore.v1_0.internal.MapUtils.lowercaseMap;
+
+import io.opentelemetry.context.Context;
+import io.opentelemetry.context.propagation.TextMapGetter;
+import io.opentelemetry.javaagent.tooling.muzzle.NoMuzzle;
+import java.util.Locale;
+import java.util.Map;
+import java.util.logging.Logger;
+
+/**
+ * This class is internal and is hence not for public use. Its APIs are unstable and can change at
+ * any time.
+ */
+public final class ParentContextExtractor {
+
+  private static final Logger logger = Logger.getLogger(ParentContextExtractor.class.getName());
+  private static final String AWS_TRACE_HEADER_ENV_KEY = "_X_AMZN_TRACE_ID";
+  private static final String AWS_TRACE_HEADER_PROP = "com.amazonaws.xray.traceHeader";
+  // lower-case map getter used for extraction
+  static final String AWS_TRACE_HEADER_PROPAGATOR_KEY = "x-amzn-trace-id";
+  static boolean getXrayTraceIdMethodExists = true;
+
+  static Context extract(
+      Map<String, String> headers,
+      AwsLambdaFunctionInstrumenter instrumenter,
+      com.amazonaws.services.lambda.runtime.Context lambdaContext) {
+    Map<String, String> mergedHeaders = lowercaseMap(headers);
+    String parentTraceHeader = getTraceHeader(lambdaContext);
+    if (parentTraceHeader != null) {
+      mergedHeaders.put(AWS_TRACE_HEADER_PROPAGATOR_KEY, parentTraceHeader);
+    }
+    return instrumenter.extract(mergedHeaders, MapGetter.INSTANCE);
+  }
+
+  @NoMuzzle
+  private static String getTraceHeader(
+      com.amazonaws.services.lambda.runtime.Context lambdaContext) {
+    String traceHeader = null;
+
+    // Lambda Core dependency that is actually used by Lambda Runtime may be on an older version
+    // that does not have the `getXrayTraceId` method. If `NoSuchMethodError` occurs, we do not
+    // attempt invoking `getXrayTraceId` again.
+    if (getXrayTraceIdMethodExists) {
+      try {
+        traceHeader = lambdaContext.getXrayTraceId();
+      } catch (NoSuchMethodError e) {
+        logger.fine("Failed to get X-Ray trace ID from lambdaContext: " + e);
+        getXrayTraceIdMethodExists = false;
+      }
+    }
+    if (traceHeader != null && !traceHeader.isEmpty()) {
+      return traceHeader;
+    }
+
+    // Lambda propagates trace header by system property instead of environment variable from java17
+    traceHeader = System.getProperty(AWS_TRACE_HEADER_PROP);
+    if (traceHeader == null || traceHeader.isEmpty()) {
+      return System.getenv(AWS_TRACE_HEADER_ENV_KEY);
+    }
+    return traceHeader;
+  }
+
+  private enum MapGetter implements TextMapGetter<Map<String, String>> {
+    INSTANCE;
+
+    @Override
+    public Iterable<String> keys(Map<String, String> map) {
+      return map.keySet();
+    }
+
+    @Override
+    public String get(Map<String, String> map, String s) {
+      return map.get(s.toLowerCase(Locale.ROOT));
+    }
+  }
+
+  private ParentContextExtractor() {}
+}
diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/test/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/InstrumenterExtractionTest.java b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/test/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/InstrumenterExtractionTest.java
index cb19d1e568..12ed174bb2 100644
--- a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/test/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/InstrumenterExtractionTest.java
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/test/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/InstrumenterExtractionTest.java
@@ -37,7 +37,7 @@ class InstrumenterExtractionTest {
 
     AwsLambdaRequest input = AwsLambdaRequest.create(awsContext, new HashMap<>(), new HashMap<>());
 
-    Context extracted = instr.extract(input);
+    Context extracted = instr.extract(input, awsContext);
     SpanContext spanContext = Span.fromContext(extracted).getSpanContext();
     assertThat(spanContext.getTraceId()).isEqualTo("4bf92f3577b34da6a3ce929d0e0e4736");
     assertThat(spanContext.getSpanId()).isEqualTo("00f067aa0ba902b7");
diff --git a/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/test/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ParentContextExtractorTest.java b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/test/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ParentContextExtractorTest.java
new file mode 100644
index 0000000000..4b0f354769
--- /dev/null
+++ b/instrumentation/aws-lambda/aws-lambda-core-1.0/library/src/test/java/io/opentelemetry/instrumentation/awslambdacore/v1_0/internal/ParentContextExtractorTest.java
@@ -0,0 +1,375 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awslambdacore.v1_0.internal;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.amazonaws.services.lambda.runtime.Context;
+import com.google.common.collect.ImmutableMap;
+import io.opentelemetry.api.OpenTelemetry;
+import io.opentelemetry.api.trace.Span;
+import io.opentelemetry.api.trace.SpanContext;
+import io.opentelemetry.context.propagation.ContextPropagators;
+import io.opentelemetry.context.propagation.TextMapPropagator;
+import io.opentelemetry.contrib.awsxray.propagator.AwsXrayPropagator;
+import io.opentelemetry.extension.trace.propagation.B3Propagator;
+import java.util.Map;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import uk.org.webcompere.systemstubs.environment.EnvironmentVariables;
+import uk.org.webcompere.systemstubs.jupiter.SystemStub;
+import uk.org.webcompere.systemstubs.jupiter.SystemStubsExtension;
+import uk.org.webcompere.systemstubs.properties.SystemProperties;
+
+/**
+ * This class is internal and is hence not for public use. Its APIs are unstable and can change at
+ * any time.
+ */
+@ExtendWith(SystemStubsExtension.class)
+class ParentContextExtractorTest {
+
+  @SystemStub final EnvironmentVariables environmentVariables = new EnvironmentVariables();
+  @SystemStub final SystemProperties systemProperties = new SystemProperties();
+
+  private static final OpenTelemetry OTEL_WITH_B3_PROPAGATOR =
+      OpenTelemetry.propagating(ContextPropagators.create(B3Propagator.injectingSingleHeader()));
+
+  private static final AwsLambdaFunctionInstrumenter INSTRUMENTER_WITH_B3_PROPAGATOR =
+      AwsLambdaFunctionInstrumenterFactory.createInstrumenter(OTEL_WITH_B3_PROPAGATOR);
+
+  // Only for new lambda context tests
+  private static final OpenTelemetry OTEL_WITH_B3_XRAY_PROPAGATORS =
+      OpenTelemetry.propagating(
+          ContextPropagators.create(
+              TextMapPropagator.composite(
+                  B3Propagator.injectingSingleHeader(), AwsXrayPropagator.getInstance())));
+  private static final OpenTelemetry OTEL_WITH_XRAY_B3_PROPAGATORS =
+      OpenTelemetry.propagating(
+          ContextPropagators.create(
+              TextMapPropagator.composite(
+                  AwsXrayPropagator.getInstance(), B3Propagator.injectingSingleHeader())));
+
+  private static final AwsLambdaFunctionInstrumenter INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS =
+      AwsLambdaFunctionInstrumenterFactory.createInstrumenter(OTEL_WITH_B3_XRAY_PROPAGATORS);
+
+  private static final AwsLambdaFunctionInstrumenter INSTRUMENTER_WITH_XRAY_B3_PROPAGATORS =
+      AwsLambdaFunctionInstrumenterFactory.createInstrumenter(OTEL_WITH_XRAY_B3_PROPAGATORS);
+
+  private static final Context mockLambdaContext = mock(Context.class);
+
+  @Test
+  void shouldUseHttpIfAwsParentNotSampled() {
+    // given
+    Map<String, String> headers =
+        ImmutableMap.of(
+            "X-b3-traceId",
+            "4fd0b6131f19f39af59518d127b0cafe",
+            "x-b3-spanid",
+            "0000000000000123",
+            "X-B3-Sampled",
+            "true");
+    environmentVariables.set(
+        "_X_AMZN_TRACE_ID",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa6;Parent=0000000000000456;Sampled=0");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(headers, INSTRUMENTER_WITH_B3_PROPAGATOR, mockLambdaContext);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000123");
+    assertThat(spanContext.getTraceId()).isEqualTo("4fd0b6131f19f39af59518d127b0cafe");
+  }
+
+  @Test
+  void shouldPreferAwsParentHeaderIfValidAndSampled() {
+    // given
+    Map<String, String> headers =
+        ImmutableMap.of(
+            "X-b3-traceId",
+            "4fd0b6131f19f39af59518d127b0cafe",
+            "x-b3-spanid",
+            "0000000000000456",
+            "X-B3-Sampled",
+            "true");
+    environmentVariables.set(
+        "_X_AMZN_TRACE_ID",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa6;Parent=0000000000000456;Sampled=1");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            headers, INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContext);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000456");
+    assertThat(spanContext.getTraceId()).isEqualTo("8a3c60f7d188f8fa79d48a391a778fa6");
+  }
+
+  @Test
+  void shouldExtractCaseInsensitiveHeaders() {
+    // given
+    Map<String, String> headers =
+        ImmutableMap.of(
+            "X-b3-traceId",
+            "4fd0b6131f19f39af59518d127b0cafe",
+            "x-b3-spanid",
+            "0000000000000456",
+            "X-B3-Sampled",
+            "true");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(headers, INSTRUMENTER_WITH_B3_PROPAGATOR, mockLambdaContext);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000456");
+    assertThat(spanContext.getTraceId()).isEqualTo("4fd0b6131f19f39af59518d127b0cafe");
+  }
+
+  @Test
+  void shouldPreferSystemPropertyOverEnvVariable() {
+    // given
+    systemProperties.set(
+        "com.amazonaws.xray.traceHeader",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa7;Parent=0000000000000789;Sampled=1");
+    environmentVariables.set(
+        "_X_AMZN_TRACE_ID",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa6;Parent=0000000000000456;Sampled=1");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            ImmutableMap.of(), INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContext);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000789");
+    assertThat(spanContext.getTraceId()).isEqualTo("8a3c60f7d188f8fa79d48a391a778fa7");
+  }
+
+  @Test
+  void shouldUseLambdaContextToExtractXrayTraceId() {
+    // given
+    Map<String, String> headers = ImmutableMap.of();
+    Context mockLambdaContextWithXrayTraceId = mock(Context.class);
+    when(mockLambdaContextWithXrayTraceId.getXrayTraceId())
+        .thenReturn("Root=1-4fd0b613-1f19f39af59518d127b0cafe;Parent=0000000000000123;Sampled=1");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            headers, INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContextWithXrayTraceId);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000123");
+    assertThat(spanContext.getTraceId()).isEqualTo("4fd0b6131f19f39af59518d127b0cafe");
+  }
+
+  @Test
+  void shouldPreferLambdaContextOverSystemProperty() {
+    // given
+    Map<String, String> headers = ImmutableMap.of();
+    Context mockLambdaContextWithXrayTraceId = mock(Context.class);
+    when(mockLambdaContextWithXrayTraceId.getXrayTraceId())
+        .thenReturn("Root=1-4fd0b613-1f19f39af59518d127b0cafe;Parent=0000000000000123;Sampled=1");
+    systemProperties.set(
+        "com.amazonaws.xray.traceHeader",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa7;Parent=0000000000000789;Sampled=1");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            headers, INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContextWithXrayTraceId);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000123");
+    assertThat(spanContext.getTraceId()).isEqualTo("4fd0b6131f19f39af59518d127b0cafe");
+  }
+
+  @Test
+  void shouldPreferLambdaContextOverEnvVariable() {
+    // given
+    Map<String, String> headers = ImmutableMap.of();
+    Context mockLambdaContextWithXrayTraceId = mock(Context.class);
+    when(mockLambdaContextWithXrayTraceId.getXrayTraceId())
+        .thenReturn("Root=1-4fd0b613-1f19f39af59518d127b0cafe;Parent=0000000000000123;Sampled=1");
+    environmentVariables.set(
+        "_X_AMZN_TRACE_ID",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa6;Parent=0000000000000456;Sampled=1");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            headers, INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContextWithXrayTraceId);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000123");
+    assertThat(spanContext.getTraceId()).isEqualTo("4fd0b6131f19f39af59518d127b0cafe");
+  }
+
+  @Test
+  void shouldPreferLambdaContextOverHttp() {
+    // given
+    Map<String, String> headers =
+        ImmutableMap.of(
+            "X-b3-traceId",
+            "4fd0b6131f19f39af59518d127b0cafe",
+            "x-b3-spanid",
+            "0000000000000123",
+            "X-B3-Sampled",
+            "true");
+    Context mockLambdaContextWithXrayTraceId = mock(Context.class);
+    when(mockLambdaContextWithXrayTraceId.getXrayTraceId())
+        .thenReturn("Root=1-8a3c60f7-d188f8fa79d48a391a778fa6;Parent=0000000000000456;Sampled=1");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            headers, INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContextWithXrayTraceId);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000456");
+    assertThat(spanContext.getTraceId()).isEqualTo("8a3c60f7d188f8fa79d48a391a778fa6");
+  }
+
+  @Test
+  void shouldPreferHttpOverXrayIdSetByLambdaContext() {
+    // given
+    Map<String, String> headers =
+        ImmutableMap.of(
+            "X-b3-traceId",
+            "4fd0b6131f19f39af59518d127b0cafe",
+            "x-b3-spanid",
+            "0000000000000123",
+            "X-B3-Sampled",
+            "true");
+    environmentVariables.set(
+        "_X_AMZN_TRACE_ID",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa6;Parent=0000000000000456;Sampled=1");
+    systemProperties.set(
+        "com.amazonaws.xray.traceHeader",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa6;Parent=0000000000000456;Sampled=1");
+    Context mockLambdaContextWithXrayTraceId = mock(Context.class);
+    when(mockLambdaContextWithXrayTraceId.getXrayTraceId())
+        .thenReturn("Root=1-8a3c60f7-d188f8fa79d48a391a778fa6;Parent=0000000000000456;Sampled=1");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            headers, INSTRUMENTER_WITH_XRAY_B3_PROPAGATORS, mockLambdaContextWithXrayTraceId);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000123");
+    assertThat(spanContext.getTraceId()).isEqualTo("4fd0b6131f19f39af59518d127b0cafe");
+  }
+
+  @Test
+  void shouldFallbackToSystemPropertyIfContextTraceIdIsNull() {
+    // given
+    Map<String, String> headers = ImmutableMap.of();
+    Context mockLambdaContextWithXrayTraceId = mock(Context.class);
+    when(mockLambdaContextWithXrayTraceId.getXrayTraceId()).thenReturn(null);
+    systemProperties.set(
+        "com.amazonaws.xray.traceHeader",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa7;Parent=0000000000000789;Sampled=1");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            headers, INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContextWithXrayTraceId);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000789");
+    assertThat(spanContext.getTraceId()).isEqualTo("8a3c60f7d188f8fa79d48a391a778fa7");
+  }
+
+  @Test
+  void shouldFallbackToSystemPropertyIfContextTraceIdIsEmptyString() {
+    // given
+    Map<String, String> headers = ImmutableMap.of();
+    Context mockLambdaContextWithXrayTraceId = mock(Context.class);
+    when(mockLambdaContextWithXrayTraceId.getXrayTraceId()).thenReturn("");
+    systemProperties.set(
+        "com.amazonaws.xray.traceHeader",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa7;Parent=0000000000000789;Sampled=1");
+
+    // when
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            headers, INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContextWithXrayTraceId);
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000789");
+    assertThat(spanContext.getTraceId()).isEqualTo("8a3c60f7d188f8fa79d48a391a778fa7");
+  }
+
+  @Test
+  void shouldFallbackToSystemPropertyWhenNoSuchMethodErrorThrown() {
+    // given
+    Map<String, String> headers = ImmutableMap.of();
+    Context mockLambdaContextWithNoSuchMethodError = mock(Context.class);
+    when(mockLambdaContextWithNoSuchMethodError.getXrayTraceId())
+        .thenThrow(new NoSuchMethodError("getXrayTraceId method not found"));
+    systemProperties.set(
+        "com.amazonaws.xray.traceHeader",
+        "Root=1-8a3c60f7-d188f8fa79d48a391a778fa7;Parent=0000000000000789;Sampled=1");
+
+    // Reset the static flag to ensure the method is attempted
+    ParentContextExtractor.getXrayTraceIdMethodExists = true;
+
+    // when - call extract
+    io.opentelemetry.context.Context context =
+        ParentContextExtractor.extract(
+            headers, INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContextWithNoSuchMethodError);
+
+    // then
+    Span span = Span.fromContext(context);
+    SpanContext spanContext = span.getSpanContext();
+    assertThat(spanContext.isValid()).isTrue();
+    assertThat(spanContext.getSpanId()).isEqualTo("0000000000000789");
+    assertThat(spanContext.getTraceId()).isEqualTo("8a3c60f7d188f8fa79d48a391a778fa7");
+    // Verify getXrayTraceId was called only once
+    assertThat(ParentContextExtractor.getXrayTraceIdMethodExists).isFalse();
+    verify(mockLambdaContextWithNoSuchMethodError, times(1)).getXrayTraceId();
+
+    // when - call extract again
+    ParentContextExtractor.extract(
+        headers, INSTRUMENTER_WITH_B3_XRAY_PROPAGATORS, mockLambdaContextWithNoSuchMethodError);
+    // Verify the call count of getXrayTraceId is still 1
+    verify(mockLambdaContextWithNoSuchMethodError, times(1)).getXrayTraceId();
+  }
+}
diff --git a/instrumentation/aws-lambda/aws-lambda-events-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdaevents/v2_2/AwsLambdaRequestHandlerInstrumentation.java b/instrumentation/aws-lambda/aws-lambda-events-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdaevents/v2_2/AwsLambdaRequestHandlerInstrumentation.java
index 8be416cb29..9ca5fbe1d0 100644
--- a/instrumentation/aws-lambda/aws-lambda-events-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdaevents/v2_2/AwsLambdaRequestHandlerInstrumentation.java
+++ b/instrumentation/aws-lambda/aws-lambda-events-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdaevents/v2_2/AwsLambdaRequestHandlerInstrumentation.java
@@ -70,7 +70,7 @@ public class AwsLambdaRequestHandlerInstrumentation implements TypeInstrumentati
       }
       input = AwsLambdaRequest.create(context, arg, headers);
       io.opentelemetry.context.Context parentContext =
-          AwsLambdaSingletons.functionInstrumenter().extract(input);
+          AwsLambdaSingletons.functionInstrumenter().extract(input, context);
 
       if (!AwsLambdaSingletons.functionInstrumenter().shouldStart(parentContext, input)) {
         return;
diff --git a/instrumentation/aws-lambda/aws-lambda-events-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdaevents/v2_2/AwsLambdaRequestStreamHandlerInstrumentation.java b/instrumentation/aws-lambda/aws-lambda-events-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdaevents/v2_2/AwsLambdaRequestStreamHandlerInstrumentation.java
index 6219a2818b..2bb3072c88 100644
--- a/instrumentation/aws-lambda/aws-lambda-events-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdaevents/v2_2/AwsLambdaRequestStreamHandlerInstrumentation.java
+++ b/instrumentation/aws-lambda/aws-lambda-events-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awslambdaevents/v2_2/AwsLambdaRequestStreamHandlerInstrumentation.java
@@ -62,7 +62,7 @@ public class AwsLambdaRequestStreamHandlerInstrumentation implements TypeInstrum
       Map<String, String> headers = Collections.emptyMap();
       otelInput = AwsLambdaRequest.create(context, input, headers);
       io.opentelemetry.context.Context parentContext =
-          AwsLambdaSingletons.functionInstrumenter().extract(otelInput);
+          AwsLambdaSingletons.functionInstrumenter().extract(otelInput, context);
 
       if (!AwsLambdaSingletons.functionInstrumenter().shouldStart(parentContext, otelInput)) {
         return;
diff --git a/instrumentation/aws-lambda/aws-lambda-events-common-2.2/library/src/main/java/io/opentelemetry/instrumentation/awslambdaevents/common/v2_2/internal/AwsLambdaSqsInstrumenterFactory.java b/instrumentation/aws-lambda/aws-lambda-events-common-2.2/library/src/main/java/io/opentelemetry/instrumentation/awslambdaevents/common/v2_2/internal/AwsLambdaSqsInstrumenterFactory.java
index e4ce0be1a9..42885201c4 100644
--- a/instrumentation/aws-lambda/aws-lambda-events-common-2.2/library/src/main/java/io/opentelemetry/instrumentation/awslambdaevents/common/v2_2/internal/AwsLambdaSqsInstrumenterFactory.java
+++ b/instrumentation/aws-lambda/aws-lambda-events-common-2.2/library/src/main/java/io/opentelemetry/instrumentation/awslambdaevents/common/v2_2/internal/AwsLambdaSqsInstrumenterFactory.java
@@ -32,7 +32,6 @@ public final class AwsLambdaSqsInstrumenterFactory {
     return Instrumenter.<SQSMessage, Void>builder(
             openTelemetry, instrumentationName, message -> message.getEventSource() + " process")
         .addAttributesExtractor(new SqsMessageAttributesExtractor())
-        .addSpanLinksExtractor(new SqsMessageSpanLinksExtractor())
         .buildInstrumenter(SpanKindExtractor.alwaysConsumer());
   }

diff --git a/version.gradle.kts b/version.gradle.kts
index 5e7f1c6775..8aefb73b5d 100644
--- a/version.gradle.kts
+++ b/version.gradle.kts
@@ -1,5 +1,5 @@
-val stableVersion = "2.23.0"
-val alphaVersion = "2.23.0-alpha"
+val stableVersion = "2.23.0-adot-lambda1"
+val alphaVersion = "2.23.0-adot-lambda1-alpha"
 
 allprojects {
   if (findProperty("otel.stable") != "true") {

