diff --git a/docs/apidiffs/current_vs_latest/opentelemetry-instrumentation-annotations.txt b/docs/apidiffs/current_vs_latest/opentelemetry-instrumentation-annotations.txt
index 93437ef1e0..3f564d25bc 100644
--- a/docs/apidiffs/current_vs_latest/opentelemetry-instrumentation-annotations.txt
+++ b/docs/apidiffs/current_vs_latest/opentelemetry-instrumentation-annotations.txt
@@ -1,2 +1,2 @@
 Comparing source compatibility of opentelemetry-instrumentation-annotations-2.11.0.jar against opentelemetry-instrumentation-annotations-2.10.0.jar
-No changes.
\ No newline at end of file
+No changes.
diff --git a/docs/apidiffs/current_vs_latest/opentelemetry-instrumentation-api.txt b/docs/apidiffs/current_vs_latest/opentelemetry-instrumentation-api.txt
index d759eed30a..385bd90663 100644
--- a/docs/apidiffs/current_vs_latest/opentelemetry-instrumentation-api.txt
+++ b/docs/apidiffs/current_vs_latest/opentelemetry-instrumentation-api.txt
@@ -1,2 +1,2 @@
 Comparing source compatibility of opentelemetry-instrumentation-api-2.11.0.jar against opentelemetry-instrumentation-api-2.10.0.jar
-No changes.
\ No newline at end of file
+No changes.
diff --git a/docs/apidiffs/current_vs_latest/opentelemetry-spring-boot-autoconfigure.txt b/docs/apidiffs/current_vs_latest/opentelemetry-spring-boot-autoconfigure.txt
index f657f219ae..2b4a59db8f 100644
--- a/docs/apidiffs/current_vs_latest/opentelemetry-spring-boot-autoconfigure.txt
+++ b/docs/apidiffs/current_vs_latest/opentelemetry-spring-boot-autoconfigure.txt
@@ -1,2 +1,2 @@
 Comparing source compatibility of opentelemetry-spring-boot-autoconfigure-2.11.0.jar against opentelemetry-spring-boot-autoconfigure-2.10.0.jar
-No changes.
\ No newline at end of file
+No changes.
diff --git a/docs/apidiffs/current_vs_latest/opentelemetry-spring-boot-starter.txt b/docs/apidiffs/current_vs_latest/opentelemetry-spring-boot-starter.txt
index 02f520fd45..99505334b7 100644
--- a/docs/apidiffs/current_vs_latest/opentelemetry-spring-boot-starter.txt
+++ b/docs/apidiffs/current_vs_latest/opentelemetry-spring-boot-starter.txt
@@ -1,2 +1,2 @@
 Comparing source compatibility of opentelemetry-spring-boot-starter-2.11.0.jar against opentelemetry-spring-boot-starter-2.10.0.jar
-No changes.
\ No newline at end of file
+No changes.
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/build.gradle.kts b/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/build.gradle.kts
index f357a19f88..fa90530579 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/build.gradle.kts
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/build.gradle.kts
@@ -47,6 +47,14 @@ dependencies {
   testLibrary("com.amazonaws:aws-java-sdk-kinesis:1.11.106")
   testLibrary("com.amazonaws:aws-java-sdk-dynamodb:1.11.106")
   testLibrary("com.amazonaws:aws-java-sdk-sns:1.11.106")
+  testLibrary("com.amazonaws:aws-java-sdk-sqs:1.11.106")
+  testLibrary("com.amazonaws:aws-java-sdk-secretsmanager:1.11.309")
+  testLibrary("com.amazonaws:aws-java-sdk-stepfunctions:1.11.230")
+  testLibrary("com.amazonaws:aws-java-sdk-lambda:1.11.678")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrock:1.12.744")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrockagent:1.12.744")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrockagentruntime:1.12.744")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrockruntime:1.12.744")
 
   testImplementation(project(":instrumentation:aws-sdk:aws-sdk-1.11:testing"))
 
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/AwsSpanAssertions.java b/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/AwsSpanAssertions.java
index 483a0c5230..460036c274 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/AwsSpanAssertions.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/AwsSpanAssertions.java
@@ -37,6 +37,7 @@ class AwsSpanAssertions {
             satisfies(stringKey("aws.endpoint"), v -> v.isInstanceOf(String.class)),
             equalTo(stringKey("aws.queue.name"), queueName),
             equalTo(stringKey("aws.queue.url"), queueUrl),
+            equalTo(stringKey("aws.auth.account.access_key"), "test"),
             satisfies(AWS_REQUEST_ID, v -> v.isInstanceOf(String.class)),
             equalTo(RPC_METHOD, rpcMethod),
             equalTo(RPC_SYSTEM, "aws-api"),
@@ -71,6 +72,7 @@ class AwsSpanAssertions {
             equalTo(RPC_METHOD, rpcMethod),
             equalTo(RPC_SYSTEM, "aws-api"),
             equalTo(RPC_SERVICE, "Amazon S3"),
+            equalTo(stringKey("aws.auth.account.access_key"), "test"),
             equalTo(HTTP_REQUEST_METHOD, requestMethod),
             equalTo(HTTP_RESPONSE_STATUS_CODE, responseStatusCode),
             satisfies(URL_FULL, val -> val.startsWith("http://")),
@@ -85,11 +87,36 @@ class AwsSpanAssertions {
   }
 
   static SpanDataAssert sns(SpanDataAssert span, String topicArn, String rpcMethod) {
-
-    return span.hasName("SNS." + rpcMethod)
+    SpanDataAssert spanAssert = span.hasName("SNS." + rpcMethod)
         .hasKind(SpanKind.CLIENT)
-        .hasNoParent()
-        .hasAttributesSatisfyingExactly(
+        .hasNoParent();
+
+    // For CreateTopic, the topicArn parameter might be null but aws.sns.topic.arn 
+    // will be set from the response
+    if ("CreateTopic".equals(rpcMethod)) {
+      return spanAssert.hasAttributesSatisfyingExactly(
+            equalTo(stringKey("aws.agent"), "java-aws-sdk"),
+            satisfies(stringKey("aws.endpoint"), v -> v.isInstanceOf(String.class)),
+            satisfies(AWS_REQUEST_ID, v -> v.isInstanceOf(String.class)),
+            equalTo(RPC_METHOD, rpcMethod),
+            equalTo(RPC_SYSTEM, "aws-api"),
+            equalTo(RPC_SERVICE, "AmazonSNS"),
+            equalTo(stringKey("aws.auth.account.access_key"), "test"),
+            equalTo(HTTP_REQUEST_METHOD, "POST"),
+            equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
+            satisfies(URL_FULL, val -> val.startsWith("http://")),
+            satisfies(SERVER_ADDRESS, v -> v.isInstanceOf(String.class)),
+            equalTo(NETWORK_PROTOCOL_VERSION, "1.1"),
+            satisfies(
+                SERVER_PORT,
+                val ->
+                    val.satisfiesAnyOf(
+                        v -> assertThat(v).isNull(),
+                        v -> assertThat(v).isInstanceOf(Number.class))),
+            satisfies(stringKey("aws.sns.topic.arn"), v -> v.isInstanceOf(String.class)));
+    }
+
+    return spanAssert.hasAttributesSatisfyingExactly(
             equalTo(stringKey("aws.agent"), "java-aws-sdk"),
             equalTo(MESSAGING_DESTINATION_NAME, topicArn),
             satisfies(stringKey("aws.endpoint"), v -> v.isInstanceOf(String.class)),
@@ -97,6 +124,7 @@ class AwsSpanAssertions {
             equalTo(RPC_METHOD, rpcMethod),
             equalTo(RPC_SYSTEM, "aws-api"),
             equalTo(RPC_SERVICE, "AmazonSNS"),
+            equalTo(stringKey("aws.auth.account.access_key"), "test"),
             equalTo(HTTP_REQUEST_METHOD, "POST"),
             equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
             satisfies(URL_FULL, val -> val.startsWith("http://")),
@@ -107,6 +135,7 @@ class AwsSpanAssertions {
                 val ->
                     val.satisfiesAnyOf(
                         v -> assertThat(v).isNull(),
-                        v -> assertThat(v).isInstanceOf(Number.class))));
+                        v -> assertThat(v).isInstanceOf(Number.class))),
+            equalTo(stringKey("aws.sns.topic.arn"), topicArn));
   }
 }
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/S3TracingTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/S3TracingTest.java
index 56eca09f8c..82c3379840 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/S3TracingTest.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/S3TracingTest.java
@@ -105,6 +105,7 @@ class S3TracingTest {
                             equalTo(RPC_METHOD, "ReceiveMessage"),
                             equalTo(RPC_SYSTEM, "aws-api"),
                             equalTo(RPC_SERVICE, "AmazonSQS"),
+                            equalTo(stringKey("aws.auth.account.access_key"), "test"),
                             equalTo(HTTP_REQUEST_METHOD, "POST"),
                             equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
                             satisfies(URL_FULL, val -> val.startsWith("http://")),
@@ -198,6 +199,7 @@ class S3TracingTest {
                             equalTo(RPC_METHOD, "ReceiveMessage"),
                             equalTo(RPC_SYSTEM, "aws-api"),
                             equalTo(RPC_SERVICE, "AmazonSQS"),
+                            equalTo(stringKey("aws.auth.account.access_key"), "test"),
                             equalTo(HTTP_REQUEST_METHOD, "POST"),
                             equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
                             satisfies(URL_FULL, val -> val.startsWith("http://")),
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/SnsTracingTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/SnsTracingTest.java
index 429ca07938..d21918bc70 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/SnsTracingTest.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/javaagent/src/test/java/io/opentelemetry/javaagent/instrumentation/awssdk/v1_11/SnsTracingTest.java
@@ -89,6 +89,7 @@ class SnsTracingTest {
                             equalTo(RPC_METHOD, "ReceiveMessage"),
                             equalTo(RPC_SYSTEM, "aws-api"),
                             equalTo(RPC_SERVICE, "AmazonSQS"),
+                            equalTo(stringKey("aws.auth.account.access_key"), "test"),
                             equalTo(HTTP_REQUEST_METHOD, "POST"),
                             equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
                             satisfies(URL_FULL, val -> val.startsWith("http://")),
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/library-autoconfigure/build.gradle.kts b/instrumentation/aws-sdk/aws-sdk-1.11/library-autoconfigure/build.gradle.kts
index 6cf49a21c4..3705634153 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/library-autoconfigure/build.gradle.kts
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/library-autoconfigure/build.gradle.kts
@@ -18,6 +18,13 @@ dependencies {
   testLibrary("com.amazonaws:aws-java-sdk-dynamodb:1.11.106")
   testLibrary("com.amazonaws:aws-java-sdk-sns:1.11.106")
   testLibrary("com.amazonaws:aws-java-sdk-sqs:1.11.106")
+  testLibrary("com.amazonaws:aws-java-sdk-secretsmanager:1.11.309")
+  testLibrary("com.amazonaws:aws-java-sdk-stepfunctions:1.11.230")
+  testLibrary("com.amazonaws:aws-java-sdk-lambda:1.11.678")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrock:1.12.744")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrockagent:1.12.744")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrockagentruntime:1.12.744")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrockruntime:1.12.744")
 
   // last version that does not use json protocol
   latestDepTestLibrary("com.amazonaws:aws-java-sdk-sqs:1.12.583")
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/library/build.gradle.kts b/instrumentation/aws-sdk/aws-sdk-1.11/library/build.gradle.kts
index bfe844e413..dec4935b55 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/library/build.gradle.kts
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/library/build.gradle.kts
@@ -17,6 +17,14 @@ dependencies {
   testLibrary("com.amazonaws:aws-java-sdk-kinesis:1.11.106")
   testLibrary("com.amazonaws:aws-java-sdk-dynamodb:1.11.106")
   testLibrary("com.amazonaws:aws-java-sdk-sns:1.11.106")
+  testLibrary("com.amazonaws:aws-java-sdk-sqs:1.11.106")
+  testLibrary("com.amazonaws:aws-java-sdk-secretsmanager:1.11.309")
+  testLibrary("com.amazonaws:aws-java-sdk-stepfunctions:1.11.230")
+  testLibrary("com.amazonaws:aws-java-sdk-lambda:1.11.678")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrock:1.12.744")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrockagent:1.12.744")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrockagentruntime:1.12.744")
+  testLibrary("com.amazonaws:aws-java-sdk-bedrockruntime:1.12.744")
 
   // last version that does not use json protocol
   latestDepTestLibrary("com.amazonaws:aws-java-sdk-sqs:1.12.583")
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsBedrockResourceType.java b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsBedrockResourceType.java
new file mode 100644
index 0000000000..e890cb3c0f
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsBedrockResourceType.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v1_11;
+
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_AGENT_ID;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_DATA_SOURCE_ID;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_KNOWLEDGE_BASE_ID;
+
+import io.opentelemetry.api.common.AttributeKey;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+
+enum AwsBedrockResourceType {
+  AGENT_TYPE(AWS_AGENT_ID, RequestAccess::getAgentId),
+  DATA_SOURCE_TYPE(AWS_DATA_SOURCE_ID, RequestAccess::getDataSourceId),
+  KNOWLEDGE_BASE_TYPE(AWS_KNOWLEDGE_BASE_ID, RequestAccess::getKnowledgeBaseId);
+
+  @SuppressWarnings("ImmutableEnumChecker")
+  private final AttributeKey<String> keyAttribute;
+
+  @SuppressWarnings("ImmutableEnumChecker")
+  private final Function<Object, String> attributeValueAccessor;
+
+  AwsBedrockResourceType(
+      AttributeKey<String> keyAttribute, Function<Object, String> attributeValueAccessor) {
+    this.keyAttribute = keyAttribute;
+    this.attributeValueAccessor = attributeValueAccessor;
+  }
+
+  public AttributeKey<String> getKeyAttribute() {
+    return keyAttribute;
+  }
+
+  public Function<Object, String> getAttributeValueAccessor() {
+    return attributeValueAccessor;
+  }
+
+  public static AwsBedrockResourceType getRequestType(String requestClass) {
+    return AwsBedrockResourceTypeMap.BEDROCK_REQUEST_MAP.get(requestClass);
+  }
+
+  public static AwsBedrockResourceType getResponseType(String responseClass) {
+    return AwsBedrockResourceTypeMap.BEDROCK_RESPONSE_MAP.get(responseClass);
+  }
+
+  private static class AwsBedrockResourceTypeMap {
+    private static final Map<String, AwsBedrockResourceType> BEDROCK_REQUEST_MAP = new HashMap<>();
+    private static final Map<String, AwsBedrockResourceType> BEDROCK_RESPONSE_MAP = new HashMap<>();
+
+    // Bedrock request/response mapping
+    // We only support operations that are related to the resource and where the context contains
+    // the AgentID/DataSourceID/KnowledgeBaseID.
+    // AgentID
+    private static final List<String> agentRequestClasses =
+        Arrays.asList(
+            "CreateAgentActionGroupRequest",
+            "CreateAgentAliasRequest",
+            "DeleteAgentActionGroupRequest",
+            "DeleteAgentAliasRequest",
+            "DeleteAgentRequest",
+            "DeleteAgentVersionRequest",
+            "GetAgentActionGroupRequest",
+            "GetAgentAliasRequest",
+            "GetAgentRequest",
+            "GetAgentVersionRequest",
+            "ListAgentActionGroupsRequest",
+            "ListAgentAliasesRequest",
+            "ListAgentKnowledgeBasesRequest",
+            "ListAgentVersionsRequest",
+            "PrepareAgentRequest",
+            "UpdateAgentActionGroupRequest",
+            "UpdateAgentAliasRequest",
+            "UpdateAgentRequest");
+    private static final List<String> agentResponseClasses =
+        Arrays.asList(
+            "DeleteAgentAliasResult",
+            "DeleteAgentResult",
+            "DeleteAgentVersionResult",
+            "PrepareAgentResult");
+    // DataSourceID
+    private static final List<String> dataSourceRequestClasses =
+        Arrays.asList("DeleteDataSourceRequest", "GetDataSourceRequest", "UpdateDataSourceRequest");
+    private static final List<String> dataSourceResponseClasses =
+        Arrays.asList("DeleteDataSourceResult");
+    // KnowledgeBaseID
+    private static final List<String> knowledgeBaseRequestClasses =
+        Arrays.asList(
+            "AssociateAgentKnowledgeBaseRequest",
+            "CreateDataSourceRequest",
+            "DeleteKnowledgeBaseRequest",
+            "DisassociateAgentKnowledgeBaseRequest",
+            "GetAgentKnowledgeBaseRequest",
+            "GetKnowledgeBaseRequest",
+            "ListDataSourcesRequest",
+            "UpdateAgentKnowledgeBaseRequest");
+    private static final List<String> knowledgeBaseResponseClasses =
+        Arrays.asList("DeleteKnowledgeBaseResult");
+
+    private AwsBedrockResourceTypeMap() {}
+
+    static {
+      // Populate the BEDROCK_REQUEST_MAP
+      for (String agentRequestClass : agentRequestClasses) {
+        BEDROCK_REQUEST_MAP.put(agentRequestClass, AwsBedrockResourceType.AGENT_TYPE);
+      }
+      for (String dataSourceRequestClass : dataSourceRequestClasses) {
+        BEDROCK_REQUEST_MAP.put(dataSourceRequestClass, AwsBedrockResourceType.DATA_SOURCE_TYPE);
+      }
+      for (String knowledgeBaseRequestClass : knowledgeBaseRequestClasses) {
+        BEDROCK_REQUEST_MAP.put(
+            knowledgeBaseRequestClass, AwsBedrockResourceType.KNOWLEDGE_BASE_TYPE);
+      }
+
+      // Populate the BEDROCK_RESPONSE_MAP
+      for (String agentResponseClass : agentResponseClasses) {
+        BEDROCK_REQUEST_MAP.put(agentResponseClass, AwsBedrockResourceType.AGENT_TYPE);
+      }
+      for (String dataSourceResponseClass : dataSourceResponseClasses) {
+        BEDROCK_REQUEST_MAP.put(dataSourceResponseClass, AwsBedrockResourceType.DATA_SOURCE_TYPE);
+      }
+      for (String knowledgeBaseResponseClass : knowledgeBaseResponseClasses) {
+        BEDROCK_REQUEST_MAP.put(
+            knowledgeBaseResponseClass, AwsBedrockResourceType.KNOWLEDGE_BASE_TYPE);
+      }
+    }
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsExperimentalAttributes.java b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsExperimentalAttributes.java
index 096c7826a1..27613c04f2 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsExperimentalAttributes.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsExperimentalAttributes.java
@@ -16,7 +16,41 @@ final class AwsExperimentalAttributes {
   static final AttributeKey<String> AWS_QUEUE_URL = stringKey("aws.queue.url");
   static final AttributeKey<String> AWS_QUEUE_NAME = stringKey("aws.queue.name");
   static final AttributeKey<String> AWS_STREAM_NAME = stringKey("aws.stream.name");
+  static final AttributeKey<String> AWS_STREAM_ARN = stringKey("aws.stream.arn");
   static final AttributeKey<String> AWS_TABLE_NAME = stringKey("aws.table.name");
+  static final AttributeKey<String> AWS_TABLE_ARN = stringKey("aws.table.arn");
+  static final AttributeKey<String> AWS_AGENT_ID = stringKey("aws.bedrock.agent.id");
+  static final AttributeKey<String> AWS_KNOWLEDGE_BASE_ID =
+      stringKey("aws.bedrock.knowledge_base.id");
+  static final AttributeKey<String> AWS_DATA_SOURCE_ID = stringKey("aws.bedrock.data_source.id");
+  static final AttributeKey<String> AWS_GUARDRAIL_ID = stringKey("aws.bedrock.guardrail.id");
+  static final AttributeKey<String> AWS_GUARDRAIL_ARN = stringKey("aws.bedrock.guardrail.arn");
+  // TODO: Merge in gen_ai attributes in opentelemetry-semconv-incubating once upgrade to v1.26.0
+  static final AttributeKey<String> AWS_BEDROCK_RUNTIME_MODEL_ID =
+      stringKey("gen_ai.request.model");
+  static final AttributeKey<String> AWS_BEDROCK_SYSTEM = stringKey("gen_ai.system");
+  static final AttributeKey<String> GEN_AI_REQUEST_MAX_TOKENS =
+      stringKey("gen_ai.request.max_tokens");
+  static final AttributeKey<String> GEN_AI_REQUEST_TEMPERATURE =
+      stringKey("gen_ai.request.temperature");
+  static final AttributeKey<String> GEN_AI_REQUEST_TOP_P = stringKey("gen_ai.request.top_p");
+  static final AttributeKey<String> GEN_AI_RESPONSE_FINISH_REASONS =
+      stringKey("gen_ai.response.finish_reasons");
+  static final AttributeKey<String> GEN_AI_USAGE_INPUT_TOKENS =
+      stringKey("gen_ai.usage.input_tokens");
+  static final AttributeKey<String> GEN_AI_USAGE_OUTPUT_TOKENS =
+      stringKey("gen_ai.usage.output_tokens");
+  static final AttributeKey<String> AWS_STATE_MACHINE_ARN =
+      stringKey("aws.stepfunctions.state_machine.arn");
+  static final AttributeKey<String> AWS_STEP_FUNCTIONS_ACTIVITY_ARN =
+      stringKey("aws.stepfunctions.activity.arn");
+  static final AttributeKey<String> AWS_SNS_TOPIC_ARN = stringKey("aws.sns.topic.arn");
+  static final AttributeKey<String> AWS_SECRET_ARN = stringKey("aws.secretsmanager.secret.arn");
+  static final AttributeKey<String> AWS_LAMBDA_NAME = stringKey("aws.lambda.function.name");
+  static final AttributeKey<String> AWS_LAMBDA_ARN = stringKey("aws.lambda.function.arn");
+  static final AttributeKey<String> AWS_LAMBDA_RESOURCE_ID =
+      stringKey("aws.lambda.resource_mapping.id");
+  static final AttributeKey<String> AWS_AUTH_ACCESS_KEY = stringKey("aws.auth.account.access_key");
 
   private AwsExperimentalAttributes() {}
 }
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsSdkExperimentalAttributesExtractor.java b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsSdkExperimentalAttributesExtractor.java
index 541e67d23b..d0e0ac71fa 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsSdkExperimentalAttributesExtractor.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AwsSdkExperimentalAttributesExtractor.java
@@ -6,25 +6,54 @@
 package io.opentelemetry.instrumentation.awssdk.v1_11;
 
 import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_AGENT;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_AGENT_ID;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_AUTH_ACCESS_KEY;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_BEDROCK_RUNTIME_MODEL_ID;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_BEDROCK_SYSTEM;
 import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_BUCKET_NAME;
 import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_ENDPOINT;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_GUARDRAIL_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_GUARDRAIL_ID;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_KNOWLEDGE_BASE_ID;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_LAMBDA_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_LAMBDA_NAME;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_LAMBDA_RESOURCE_ID;
 import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_QUEUE_NAME;
 import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_QUEUE_URL;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_SECRET_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_SNS_TOPIC_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_STATE_MACHINE_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_STEP_FUNCTIONS_ACTIVITY_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_STREAM_ARN;
 import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_STREAM_NAME;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_TABLE_ARN;
 import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.AWS_TABLE_NAME;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.GEN_AI_REQUEST_MAX_TOKENS;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.GEN_AI_REQUEST_TEMPERATURE;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.GEN_AI_REQUEST_TOP_P;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.GEN_AI_RESPONSE_FINISH_REASONS;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.GEN_AI_USAGE_INPUT_TOKENS;
+import static io.opentelemetry.instrumentation.awssdk.v1_11.AwsExperimentalAttributes.GEN_AI_USAGE_OUTPUT_TOKENS;
 
 import com.amazonaws.Request;
 import com.amazonaws.Response;
+import com.amazonaws.auth.AWSCredentials;
+import com.amazonaws.handlers.HandlerContextKey;
 import io.opentelemetry.api.common.AttributeKey;
 import io.opentelemetry.api.common.AttributesBuilder;
 import io.opentelemetry.context.Context;
 import io.opentelemetry.instrumentation.api.instrumenter.AttributesExtractor;
+import java.util.Objects;
 import java.util.function.Function;
 import javax.annotation.Nullable;
 
 class AwsSdkExperimentalAttributesExtractor
     implements AttributesExtractor<Request<?>, Response<?>> {
   private static final String COMPONENT_NAME = "java-aws-sdk";
+  private static final String BEDROCK_SERVICE = "AmazonBedrock";
+  private static final String BEDROCK_AGENT_SERVICE = "AWSBedrockAgent";
+  private static final String BEDROCK_AGENT_RUNTIME_SERVICE = "AWSBedrockAgentRuntime";
+  private static final String BEDROCK_RUNTIME_SERVICE = "AmazonBedrockRuntime";
 
   @Override
   public void onStart(AttributesBuilder attributes, Context parentContext, Request<?> request) {
@@ -32,14 +61,166 @@ class AwsSdkExperimentalAttributesExtractor
     attributes.put(AWS_ENDPOINT, request.getEndpoint().toString());
 
     Object originalRequest = request.getOriginalRequest();
-    setRequestAttribute(attributes, AWS_BUCKET_NAME, originalRequest, RequestAccess::getBucketName);
-    setRequestAttribute(attributes, AWS_QUEUE_URL, originalRequest, RequestAccess::getQueueUrl);
-    setRequestAttribute(attributes, AWS_QUEUE_NAME, originalRequest, RequestAccess::getQueueName);
-    setRequestAttribute(attributes, AWS_STREAM_NAME, originalRequest, RequestAccess::getStreamName);
-    setRequestAttribute(attributes, AWS_TABLE_NAME, originalRequest, RequestAccess::getTableName);
+    String requestClassName = originalRequest.getClass().getSimpleName();
+
+    AWSCredentials credentials = request.getHandlerContext(HandlerContextKey.AWS_CREDENTIALS);
+    if (credentials != null) {
+      String accessKeyId = credentials.getAWSAccessKeyId();
+      if (accessKeyId != null) {
+        attributes.put(AWS_AUTH_ACCESS_KEY, accessKeyId);
+      }
+    }
+    setAttribute(attributes, AWS_BUCKET_NAME, originalRequest, RequestAccess::getBucketName);
+    setAttribute(attributes, AWS_QUEUE_URL, originalRequest, RequestAccess::getQueueUrl);
+    setAttribute(attributes, AWS_QUEUE_NAME, originalRequest, RequestAccess::getQueueName);
+    setAttribute(attributes, AWS_STREAM_NAME, originalRequest, RequestAccess::getStreamName);
+    setAttribute(attributes, AWS_STREAM_ARN, originalRequest, RequestAccess::getStreamArn);
+    setAttribute(attributes, AWS_TABLE_NAME, originalRequest, RequestAccess::getTableName);
+    setAttribute(
+        attributes, AWS_STATE_MACHINE_ARN, originalRequest, RequestAccess::getStateMachineArn);
+    setAttribute(
+        attributes,
+        AWS_STEP_FUNCTIONS_ACTIVITY_ARN,
+        originalRequest,
+        RequestAccess::getStepFunctionsActivityArn);
+    setAttribute(attributes, AWS_SNS_TOPIC_ARN, originalRequest, RequestAccess::getSnsTopicArn);
+    setAttribute(attributes, AWS_SECRET_ARN, originalRequest, RequestAccess::getSecretArn);
+    setAttribute(attributes, AWS_LAMBDA_NAME, originalRequest, RequestAccess::getLambdaName);
+    setAttribute(
+        attributes, AWS_LAMBDA_RESOURCE_ID, originalRequest, RequestAccess::getLambdaResourceId);
+    // Get serviceName defined in the AWS Java SDK V1 Request class.
+    String serviceName = request.getServiceName();
+    // Extract request attributes only for Bedrock services.
+    if (isBedrockService(serviceName)) {
+      bedrockOnStart(attributes, originalRequest, requestClassName, serviceName);
+    }
+  }
+
+  @Override
+  public void onEnd(
+      AttributesBuilder attributes,
+      Context context,
+      Request<?> request,
+      @Nullable Response<?> response,
+      @Nullable Throwable error) {
+    if (response != null) {
+      Object awsResp = response.getAwsResponse();
+      setAttribute(attributes, AWS_TABLE_ARN, awsResp, RequestAccess::getTableArn);
+      setAttribute(attributes, AWS_LAMBDA_ARN, awsResp, RequestAccess::getLambdaArn);
+      setAttribute(attributes, AWS_STATE_MACHINE_ARN, awsResp, RequestAccess::getStateMachineArn);
+      setAttribute(
+          attributes,
+          AWS_STEP_FUNCTIONS_ACTIVITY_ARN,
+          awsResp,
+          RequestAccess::getStepFunctionsActivityArn);
+      setAttribute(attributes, AWS_SNS_TOPIC_ARN, awsResp, RequestAccess::getSnsTopicArn);
+      setAttribute(attributes, AWS_SECRET_ARN, awsResp, RequestAccess::getSecretArn);
+      // Get serviceName defined in the AWS Java SDK V1 Request class.
+      String serviceName = request.getServiceName();
+      // Extract response attributes for Bedrock services
+      if (awsResp != null && isBedrockService(serviceName)) {
+        bedrockOnEnd(attributes, awsResp, serviceName);
+      }
+    }
+  }
+
+  private static void bedrockOnStart(
+      AttributesBuilder attributes,
+      Object originalRequest,
+      String requestClassName,
+      String serviceName) {
+    switch (serviceName) {
+      case BEDROCK_SERVICE:
+        setAttribute(attributes, AWS_GUARDRAIL_ID, originalRequest, RequestAccess::getGuardrailId);
+        break;
+      case BEDROCK_AGENT_SERVICE:
+        AwsBedrockResourceType resourceType =
+            AwsBedrockResourceType.getRequestType(requestClassName);
+        if (resourceType != null) {
+          setAttribute(
+              attributes,
+              resourceType.getKeyAttribute(),
+              originalRequest,
+              resourceType.getAttributeValueAccessor());
+        }
+        break;
+      case BEDROCK_AGENT_RUNTIME_SERVICE:
+        setAttribute(attributes, AWS_AGENT_ID, originalRequest, RequestAccess::getAgentId);
+        setAttribute(
+            attributes, AWS_KNOWLEDGE_BASE_ID, originalRequest, RequestAccess::getKnowledgeBaseId);
+        break;
+      case BEDROCK_RUNTIME_SERVICE:
+        if (!Objects.equals(requestClassName, "InvokeModelRequest")) {
+          break;
+        }
+        attributes.put(AWS_BEDROCK_SYSTEM, "aws.bedrock");
+        Function<Object, String> getter = RequestAccess::getModelId;
+        String modelId = getter.apply(originalRequest);
+        attributes.put(AWS_BEDROCK_RUNTIME_MODEL_ID, modelId);
+
+        setAttribute(
+            attributes, GEN_AI_REQUEST_MAX_TOKENS, originalRequest, RequestAccess::getMaxTokens);
+        setAttribute(
+            attributes, GEN_AI_REQUEST_TEMPERATURE, originalRequest, RequestAccess::getTemperature);
+        setAttribute(attributes, GEN_AI_REQUEST_TOP_P, originalRequest, RequestAccess::getTopP);
+        setAttribute(
+            attributes, GEN_AI_USAGE_INPUT_TOKENS, originalRequest, RequestAccess::getInputTokens);
+        break;
+      default:
+        break;
+    }
+  }
+
+  private static void bedrockOnEnd(
+      AttributesBuilder attributes, Object awsResp, String serviceName) {
+    switch (serviceName) {
+      case BEDROCK_SERVICE:
+        setAttribute(attributes, AWS_GUARDRAIL_ID, awsResp, RequestAccess::getGuardrailId);
+        setAttribute(attributes, AWS_GUARDRAIL_ARN, awsResp, RequestAccess::getGuardrailArn);
+        break;
+      case BEDROCK_AGENT_SERVICE:
+        String responseClassName = awsResp.getClass().getSimpleName();
+        AwsBedrockResourceType resourceType =
+            AwsBedrockResourceType.getResponseType(responseClassName);
+        if (resourceType != null) {
+          setAttribute(
+              attributes,
+              resourceType.getKeyAttribute(),
+              awsResp,
+              resourceType.getAttributeValueAccessor());
+        }
+        break;
+      case BEDROCK_AGENT_RUNTIME_SERVICE:
+        setAttribute(attributes, AWS_AGENT_ID, awsResp, RequestAccess::getAgentId);
+        setAttribute(attributes, AWS_KNOWLEDGE_BASE_ID, awsResp, RequestAccess::getKnowledgeBaseId);
+        break;
+      case BEDROCK_RUNTIME_SERVICE:
+        if (!Objects.equals(awsResp.getClass().getSimpleName(), "InvokeModelResult")) {
+          break;
+        }
+
+        setAttribute(attributes, GEN_AI_USAGE_INPUT_TOKENS, awsResp, RequestAccess::getInputTokens);
+        setAttribute(
+            attributes, GEN_AI_USAGE_OUTPUT_TOKENS, awsResp, RequestAccess::getOutputTokens);
+        setAttribute(
+            attributes, GEN_AI_RESPONSE_FINISH_REASONS, awsResp, RequestAccess::getFinishReasons);
+        break;
+      default:
+        break;
+    }
+  }
+
+  private static boolean isBedrockService(String serviceName) {
+    // Check if the serviceName belongs to Bedrock Services defined in AWS Java SDK V1.
+    // For example <a
+    // href="https://github.com/aws/aws-sdk-java/blob/38031248a696468e19a4670c0c4585637d5e7cc6/aws-java-sdk-bedrock/src/main/java/com/amazonaws/services/bedrock/AmazonBedrock.java#L34">AmazonBedrock</a>
+    return serviceName.equals(BEDROCK_SERVICE)
+        || serviceName.equals(BEDROCK_AGENT_SERVICE)
+        || serviceName.equals(BEDROCK_AGENT_RUNTIME_SERVICE)
+        || serviceName.equals(BEDROCK_RUNTIME_SERVICE);
   }
 
-  private static void setRequestAttribute(
+  private static void setAttribute(
       AttributesBuilder attributes,
       AttributeKey<String> key,
       Object request,
@@ -49,12 +230,4 @@ class AwsSdkExperimentalAttributesExtractor
       attributes.put(key, value);
     }
   }
-
-  @Override
-  public void onEnd(
-      AttributesBuilder attributes,
-      Context context,
-      Request<?> request,
-      @Nullable Response<?> response,
-      @Nullable Throwable error) {}
 }
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/BedrockJsonParser.java b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/BedrockJsonParser.java
new file mode 100644
index 0000000000..d1acc5768a
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/BedrockJsonParser.java
@@ -0,0 +1,267 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v1_11;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class BedrockJsonParser {
+
+  // Prevent instantiation
+  private BedrockJsonParser() {
+    throw new UnsupportedOperationException("Utility class");
+  }
+
+  public static LlmJson parse(String jsonString) {
+    JsonParser parser = new JsonParser(jsonString);
+    Map<String, Object> jsonBody = parser.parse();
+    return new LlmJson(jsonBody);
+  }
+
+  static class JsonParser {
+    private final String json;
+    private int position;
+
+    public JsonParser(String json) {
+      this.json = json.trim();
+      this.position = 0;
+    }
+
+    private void skipWhitespace() {
+      while (position < json.length() && Character.isWhitespace(json.charAt(position))) {
+        position++;
+      }
+    }
+
+    private char currentChar() {
+      return json.charAt(position);
+    }
+
+    private static boolean isHexDigit(char c) {
+      return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
+    }
+
+    private void expect(char c) {
+      skipWhitespace();
+      if (currentChar() != c) {
+        throw new IllegalArgumentException(
+            "Expected '" + c + "' but found '" + currentChar() + "'");
+      }
+      position++;
+    }
+
+    private String readString() {
+      skipWhitespace();
+      expect('"'); // Ensure the string starts with a quote
+      StringBuilder result = new StringBuilder();
+      while (currentChar() != '"') {
+        // Handle escape sequences
+        if (currentChar() == '\\') {
+          position++; // Move past the backslash
+          if (position >= json.length()) {
+            throw new IllegalArgumentException("Unexpected end of input in string escape sequence");
+          }
+          char escapeChar = currentChar();
+          switch (escapeChar) {
+            case '"':
+            case '\\':
+            case '/':
+              result.append(escapeChar);
+              break;
+            case 'b':
+              result.append('\b');
+              break;
+            case 'f':
+              result.append('\f');
+              break;
+            case 'n':
+              result.append('\n');
+              break;
+            case 'r':
+              result.append('\r');
+              break;
+            case 't':
+              result.append('\t');
+              break;
+            case 'u': // Unicode escape sequence
+              if (position + 4 >= json.length()) {
+                throw new IllegalArgumentException("Invalid unicode escape sequence in string");
+              }
+              char[] hexChars = new char[4];
+              for (int i = 0; i < 4; i++) {
+                position++; // Move to the next character
+                char hexChar = json.charAt(position);
+                if (!isHexDigit(hexChar)) {
+                  throw new IllegalArgumentException(
+                      "Invalid hexadecimal digit in unicode escape sequence");
+                }
+                hexChars[i] = hexChar;
+              }
+              int unicodeValue = Integer.parseInt(new String(hexChars), 16);
+              result.append((char) unicodeValue);
+              break;
+            default:
+              throw new IllegalArgumentException("Invalid escape character: \\" + escapeChar);
+          }
+          position++;
+        } else {
+          result.append(currentChar());
+          position++;
+        }
+      }
+      position++; // Skip closing quote
+      return result.toString();
+    }
+
+    private Object readValue() {
+      skipWhitespace();
+      char c = currentChar();
+
+      if (c == '"') {
+        return readString();
+      } else if (Character.isDigit(c)) {
+        return readScopedNumber();
+      } else if (c == '{') {
+        return readObject(); // JSON Objects
+      } else if (c == '[') {
+        return readArray(); // JSON Arrays
+      } else if (json.startsWith("true", position)) {
+        position += 4;
+        return true;
+      } else if (json.startsWith("false", position)) {
+        position += 5;
+        return false;
+      } else if (json.startsWith("null", position)) {
+        position += 4;
+        return null; // JSON null
+      } else {
+        throw new IllegalArgumentException("Unexpected character: " + c);
+      }
+    }
+
+    private Number readScopedNumber() {
+      int start = position;
+
+      // Consume digits and the optional decimal point
+      while (position < json.length()
+          && (Character.isDigit(json.charAt(position)) || json.charAt(position) == '.')) {
+        position++;
+      }
+
+      String number = json.substring(start, position);
+
+      if (number.contains(".")) {
+        double value = Double.parseDouble(number);
+        if (value < 0.0 || value > 1.0) {
+          throw new IllegalArgumentException(
+              "Value out of bounds for Bedrock Floating Point Attribute: " + number);
+        }
+        return value;
+      } else {
+        return Integer.parseInt(number);
+      }
+    }
+
+    private Map<String, Object> readObject() {
+      Map<String, Object> map = new HashMap<>();
+      expect('{');
+      skipWhitespace();
+      while (currentChar() != '}') {
+        String key = readString();
+        expect(':');
+        Object value = readValue();
+        map.put(key, value);
+        skipWhitespace();
+        if (currentChar() == ',') {
+          position++;
+        }
+      }
+      position++; // Skip closing brace
+      return map;
+    }
+
+    private List<Object> readArray() {
+      List<Object> list = new ArrayList<>();
+      expect('[');
+      skipWhitespace();
+      while (currentChar() != ']') {
+        list.add(readValue());
+        skipWhitespace();
+        if (currentChar() == ',') {
+          position++;
+        }
+      }
+      position++;
+      return list;
+    }
+
+    public Map<String, Object> parse() {
+      return readObject();
+    }
+  }
+
+  // Resolves paths in a JSON structure
+  static class JsonPathResolver {
+
+    // Private constructor to prevent instantiation
+    private JsonPathResolver() {
+      throw new UnsupportedOperationException("Utility class");
+    }
+
+    public static Object resolvePath(LlmJson llmJson, String... paths) {
+      for (String path : paths) {
+        Object value = resolvePath(llmJson.getJsonBody(), path);
+        if (value != null) {
+          return value;
+        }
+      }
+      return null;
+    }
+
+    private static Object resolvePath(Map<String, Object> json, String path) {
+      String[] keys = path.split("/");
+      Object current = json;
+
+      for (String key : keys) {
+        if (key.isEmpty()) {
+          continue;
+        }
+
+        if (current instanceof Map) {
+          current = ((Map<?, ?>) current).get(key);
+        } else if (current instanceof List) {
+          try {
+            int index = Integer.parseInt(key);
+            current = ((List<?>) current).get(index);
+          } catch (NumberFormatException | IndexOutOfBoundsException e) {
+            return null;
+          }
+        } else {
+          return null;
+        }
+
+        if (current == null) {
+          return null;
+        }
+      }
+      return current;
+    }
+  }
+
+  public static class LlmJson {
+    private final Map<String, Object> jsonBody;
+
+    public LlmJson(Map<String, Object> jsonBody) {
+      this.jsonBody = jsonBody;
+    }
+
+    public Map<String, Object> getJsonBody() {
+      return jsonBody;
+    }
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/RequestAccess.java b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/RequestAccess.java
index c212a69678..82a7185abe 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/RequestAccess.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/RequestAccess.java
@@ -8,6 +8,12 @@ package io.opentelemetry.instrumentation.awssdk.v1_11;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
+import java.lang.reflect.Method;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
 final class RequestAccess {
@@ -20,48 +26,417 @@ final class RequestAccess {
         }
       };
 
+  @Nullable
+  private static BedrockJsonParser.LlmJson parseTargetBody(ByteBuffer buffer) {
+    try {
+      byte[] bytes;
+      // Create duplicate to avoid mutating the original buffer position
+      ByteBuffer duplicate = buffer.duplicate();
+      if (buffer.hasArray()) {
+        bytes =
+            Arrays.copyOfRange(
+                duplicate.array(),
+                duplicate.arrayOffset(),
+                duplicate.arrayOffset() + duplicate.remaining());
+      } else {
+        bytes = new byte[buffer.remaining()];
+        buffer.get(bytes);
+      }
+      String jsonString = new String(bytes, StandardCharsets.UTF_8); // Convert to String
+      return BedrockJsonParser.parse(jsonString);
+    } catch (RuntimeException e) {
+      return null;
+    }
+  }
+
+  @Nullable
+  private static BedrockJsonParser.LlmJson getJsonBody(Object target) {
+    if (target == null) {
+      return null;
+    }
+
+    RequestAccess access = REQUEST_ACCESSORS.get(target.getClass());
+    ByteBuffer bodyBuffer = invokeOrNullGeneric(access.getBody, target, ByteBuffer.class);
+    if (bodyBuffer == null) {
+      return null;
+    }
+
+    return parseTargetBody(bodyBuffer);
+  }
+
+  @Nullable
+  private static String findFirstMatchingPath(BedrockJsonParser.LlmJson jsonBody, String... paths) {
+    if (jsonBody == null) {
+      return null;
+    }
+
+    return Stream.of(paths)
+        .map(path -> BedrockJsonParser.JsonPathResolver.resolvePath(jsonBody, path))
+        .filter(Objects::nonNull)
+        .map(Object::toString)
+        .findFirst()
+        .orElse(null);
+  }
+
+  @Nullable
+  private static String approximateTokenCount(
+      BedrockJsonParser.LlmJson jsonBody, String... textPaths) {
+    if (jsonBody == null) {
+      return null;
+    }
+
+    return Stream.of(textPaths)
+        .map(path -> BedrockJsonParser.JsonPathResolver.resolvePath(jsonBody, path))
+        .filter(value -> value instanceof String)
+        .map(value -> Integer.toString((int) Math.ceil(((String) value).length() / 6.0)))
+        .findFirst()
+        .orElse(null);
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/inferenceConfig/max_new_tokens"
+  // Amazon Titan -> "/textGenerationConfig/maxTokenCount"
+  // Anthropic Claude -> "/max_tokens"
+  // Cohere Command -> "/max_tokens"
+  // Cohere Command R -> "/max_tokens"
+  // AI21 Jamba -> "/max_tokens"
+  // Meta Llama -> "/max_gen_len"
+  // Mistral AI -> "/max_tokens"
+  @Nullable
+  static String getMaxTokens(Object target) {
+    BedrockJsonParser.LlmJson jsonBody = getJsonBody(target);
+    return findFirstMatchingPath(
+        jsonBody,
+        "/max_tokens",
+        "/max_gen_len",
+        "/textGenerationConfig/maxTokenCount",
+        "/inferenceConfig/max_new_tokens");
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/inferenceConfig/temperature"
+  // Amazon Titan -> "/textGenerationConfig/temperature"
+  // Anthropic Claude -> "/temperature"
+  // Cohere Command -> "/temperature"
+  // Cohere Command R -> "/temperature"
+  // AI21 Jamba -> "/temperature"
+  // Meta Llama -> "/temperature"
+  // Mistral AI -> "/temperature"
+  @Nullable
+  static String getTemperature(Object target) {
+    BedrockJsonParser.LlmJson jsonBody = getJsonBody(target);
+    return findFirstMatchingPath(
+        jsonBody,
+        "/temperature",
+        "/textGenerationConfig/temperature",
+        "inferenceConfig/temperature");
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/inferenceConfig/top_p"
+  // Amazon Titan -> "/textGenerationConfig/topP"
+  // Anthropic Claude -> "/top_p"
+  // Cohere Command -> "/p"
+  // Cohere Command R -> "/p"
+  // AI21 Jamba -> "/top_p"
+  // Meta Llama -> "/top_p"
+  // Mistral AI -> "/top_p"
+  @Nullable
+  static String getTopP(Object target) {
+    BedrockJsonParser.LlmJson jsonBody = getJsonBody(target);
+    return findFirstMatchingPath(
+        jsonBody, "/top_p", "/p", "/textGenerationConfig/topP", "/inferenceConfig/top_p");
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/usage/inputTokens"
+  // Amazon Titan -> "/inputTextTokenCount"
+  // Anthropic Claude -> "/usage/input_tokens"
+  // Cohere Command -> "/prompt"
+  // Cohere Command R -> "/message"
+  // AI21 Jamba -> "/usage/prompt_tokens"
+  // Meta Llama -> "/prompt_token_count"
+  // Mistral AI -> "/prompt"
+  @Nullable
+  static String getInputTokens(Object target) {
+    BedrockJsonParser.LlmJson jsonBody = getJsonBody(target);
+    if (jsonBody == null) {
+      return null;
+    }
+
+    // Try direct token counts first
+    String directCount =
+        findFirstMatchingPath(
+            jsonBody,
+            "/inputTextTokenCount",
+            "/prompt_token_count",
+            "/usage/input_tokens",
+            "/usage/prompt_tokens",
+            "/usage/inputTokens");
+
+    if (directCount != null && !directCount.equals("null")) {
+      return directCount;
+    }
+
+    // Fall back to token approximation
+    return approximateTokenCount(jsonBody, "/prompt", "/message");
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/usage/outputTokens"
+  // Amazon Titan -> "/results/0/tokenCount"
+  // Anthropic Claude -> "/usage/output_tokens"
+  // Cohere Command -> "/generations/0/text"
+  // Cohere Command R -> "/text"
+  // AI21 Jamba -> "/usage/completion_tokens"
+  // Meta Llama -> "/generation_token_count"
+  // Mistral AI -> "/outputs/0/text"
+  @Nullable
+  static String getOutputTokens(Object target) {
+    BedrockJsonParser.LlmJson jsonBody = getJsonBody(target);
+    if (jsonBody == null) {
+      return null;
+    }
+
+    // Try direct token counts first
+    String directCount =
+        findFirstMatchingPath(
+            jsonBody,
+            "/generation_token_count",
+            "/results/0/tokenCount",
+            "/usage/output_tokens",
+            "/usage/completion_tokens",
+            "/usage/outputTokens");
+
+    if (directCount != null && !directCount.equals("null")) {
+      return directCount;
+    }
+
+    // Fall back to token approximation
+    return approximateTokenCount(jsonBody, "/text", "/outputs/0/text");
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/stopReason"
+  // Amazon Titan -> "/results/0/completionReason"
+  // Anthropic Claude -> "/stop_reason"
+  // Cohere Command -> "/generations/0/finish_reason"
+  // Cohere Command R -> "/finish_reason"
+  // AI21 Jamba -> "/choices/0/finish_reason"
+  // Meta Llama -> "/stop_reason"
+  // Mistral AI -> "/outputs/0/stop_reason"
+  @Nullable
+  static String getFinishReasons(Object target) {
+    BedrockJsonParser.LlmJson jsonBody = getJsonBody(target);
+    String finishReason =
+        findFirstMatchingPath(
+            jsonBody,
+            "/stopReason",
+            "/finish_reason",
+            "/stop_reason",
+            "/results/0/completionReason",
+            "/generations/0/finish_reason",
+            "/choices/0/finish_reason",
+            "/outputs/0/stop_reason");
+
+    return finishReason != null ? "[" + finishReason + "]" : null;
+  }
+
+  @Nullable
+  static String getLambdaName(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getLambdaName, request);
+  }
+
+  @Nullable
+  static String getLambdaArn(Object request) {
+    if (request == null) {
+      return null;
+    }
+    return findNestedAccessorOrNull(request, "getConfiguration", "getFunctionArn");
+  }
+
+  @Nullable
+  static String getLambdaResourceId(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getLambdaResourceId, request);
+  }
+
+  @Nullable
+  static String getSecretArn(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getSecretArn, request);
+  }
+
+  @Nullable
+  static String getSnsTopicArn(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getSnsTopicArn, request);
+  }
+
+  @Nullable
+  static String getStepFunctionsActivityArn(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getStepFunctionsActivityArn, request);
+  }
+
+  @Nullable
+  static String getStateMachineArn(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getStateMachineArn, request);
+  }
+
   @Nullable
   static String getBucketName(Object request) {
+    if (request == null) {
+      return null;
+    }
     RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
     return invokeOrNull(access.getBucketName, request);
   }
 
   @Nullable
   static String getQueueUrl(Object request) {
+    if (request == null) {
+      return null;
+    }
     RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
     return invokeOrNull(access.getQueueUrl, request);
   }
 
   @Nullable
   static String getQueueName(Object request) {
+    if (request == null) {
+      return null;
+    }
     RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
     return invokeOrNull(access.getQueueName, request);
   }
 
   @Nullable
   static String getStreamName(Object request) {
+    if (request == null) {
+      return null;
+    }
     RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
     return invokeOrNull(access.getStreamName, request);
   }
 
   @Nullable
   static String getTableName(Object request) {
+    if (request == null) {
+      return null;
+    }
     RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
     return invokeOrNull(access.getTableName, request);
   }
 
+  @Nullable
+  static String getTableArn(Object request) {
+    if (request == null) {
+      return null;
+    }
+    return findNestedAccessorOrNull(request, "getTable", "getTableArn");
+  }
+
+  @Nullable
+  static String getStreamArn(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getStreamArn, request);
+  }
+
   @Nullable
   static String getTopicArn(Object request) {
+    if (request == null) {
+      return null;
+    }
     RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
     return invokeOrNull(access.getTopicArn, request);
   }
 
   @Nullable
   static String getTargetArn(Object request) {
+    if (request == null) {
+      return null;
+    }
     RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
     return invokeOrNull(access.getTargetArn, request);
   }
 
+  @Nullable
+  static String getAgentId(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getAgentId, request);
+  }
+
+  @Nullable
+  static String getKnowledgeBaseId(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getKnowledgeBaseId, request);
+  }
+
+  @Nullable
+  static String getDataSourceId(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getDataSourceId, request);
+  }
+
+  @Nullable
+  static String getGuardrailId(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getGuardrailId, request);
+  }
+
+  @Nullable
+  static String getGuardrailArn(Object request) {
+    if (request == null) {
+      return null;
+    }
+    return findNestedAccessorOrNull(request, "getGuardrailArn");
+  }
+
+  @Nullable
+  static String getModelId(Object request) {
+    if (request == null) {
+      return null;
+    }
+    RequestAccess access = REQUEST_ACCESSORS.get(request.getClass());
+    return invokeOrNull(access.getModelId, request);
+  }
+
   @Nullable
   private static String invokeOrNull(@Nullable MethodHandle method, Object obj) {
     if (method == null) {
@@ -74,31 +449,88 @@ final class RequestAccess {
     }
   }
 
+  @Nullable
+  private static <T> T invokeOrNullGeneric(
+      @Nullable MethodHandle method, Object obj, Class<T> returnType) {
+    if (method == null) {
+      return null;
+    }
+    try {
+      return returnType.cast(method.invoke(obj));
+    } catch (Throwable e) {
+      return null;
+    }
+  }
+
   @Nullable private final MethodHandle getBucketName;
   @Nullable private final MethodHandle getQueueUrl;
   @Nullable private final MethodHandle getQueueName;
   @Nullable private final MethodHandle getStreamName;
+  @Nullable private final MethodHandle getStreamArn;
   @Nullable private final MethodHandle getTableName;
   @Nullable private final MethodHandle getTopicArn;
   @Nullable private final MethodHandle getTargetArn;
+  @Nullable private final MethodHandle getAgentId;
+  @Nullable private final MethodHandle getKnowledgeBaseId;
+  @Nullable private final MethodHandle getDataSourceId;
+  @Nullable private final MethodHandle getGuardrailId;
+  @Nullable private final MethodHandle getModelId;
+  @Nullable private final MethodHandle getBody;
+  @Nullable private final MethodHandle getStateMachineArn;
+  @Nullable private final MethodHandle getStepFunctionsActivityArn;
+  @Nullable private final MethodHandle getSnsTopicArn;
+  @Nullable private final MethodHandle getSecretArn;
+  @Nullable private final MethodHandle getLambdaName;
+  @Nullable private final MethodHandle getLambdaResourceId;
 
   private RequestAccess(Class<?> clz) {
-    getBucketName = findAccessorOrNull(clz, "getBucketName");
-    getQueueUrl = findAccessorOrNull(clz, "getQueueUrl");
-    getQueueName = findAccessorOrNull(clz, "getQueueName");
-    getStreamName = findAccessorOrNull(clz, "getStreamName");
-    getTableName = findAccessorOrNull(clz, "getTableName");
-    getTopicArn = findAccessorOrNull(clz, "getTopicArn");
-    getTargetArn = findAccessorOrNull(clz, "getTargetArn");
+    getBucketName = findAccessorOrNull(clz, "getBucketName", String.class);
+    getQueueUrl = findAccessorOrNull(clz, "getQueueUrl", String.class);
+    getQueueName = findAccessorOrNull(clz, "getQueueName", String.class);
+    getStreamName = findAccessorOrNull(clz, "getStreamName", String.class);
+    getStreamArn = findAccessorOrNull(clz, "getStreamARN", String.class);
+    getTableName = findAccessorOrNull(clz, "getTableName", String.class);
+    getTopicArn = findAccessorOrNull(clz, "getTopicArn", String.class);
+    getTargetArn = findAccessorOrNull(clz, "getTargetArn", String.class);
+    getAgentId = findAccessorOrNull(clz, "getAgentId", String.class);
+    getKnowledgeBaseId = findAccessorOrNull(clz, "getKnowledgeBaseId", String.class);
+    getDataSourceId = findAccessorOrNull(clz, "getDataSourceId", String.class);
+    getGuardrailId = findAccessorOrNull(clz, "getGuardrailId", String.class);
+    getModelId = findAccessorOrNull(clz, "getModelId", String.class);
+    getBody = findAccessorOrNull(clz, "getBody", ByteBuffer.class);
+    getStateMachineArn = findAccessorOrNull(clz, "getStateMachineArn", String.class);
+    getStepFunctionsActivityArn = findAccessorOrNull(clz, "getActivityArn", String.class);
+    getSnsTopicArn = findAccessorOrNull(clz, "getTopicArn", String.class);
+    getSecretArn = findAccessorOrNull(clz, "getARN", String.class);
+    getLambdaName = findAccessorOrNull(clz, "getFunctionName", String.class);
+    getLambdaResourceId = findAccessorOrNull(clz, "getUUID", String.class);
   }
 
   @Nullable
-  private static MethodHandle findAccessorOrNull(Class<?> clz, String methodName) {
+  private static MethodHandle findAccessorOrNull(
+      Class<?> clz, String methodName, Class<?> returnType) {
     try {
       return MethodHandles.publicLookup()
-          .findVirtual(clz, methodName, MethodType.methodType(String.class));
+          .findVirtual(clz, methodName, MethodType.methodType(returnType));
     } catch (Throwable t) {
       return null;
     }
   }
+
+  @Nullable
+  private static String findNestedAccessorOrNull(Object obj, String... methodNames) {
+    Object current = obj;
+    for (String methodName : methodNames) {
+      if (current == null) {
+        return null;
+      }
+      try {
+        Method method = current.getClass().getMethod(methodName);
+        current = method.invoke(current);
+      } catch (Exception e) {
+        return null;
+      }
+    }
+    return (current instanceof String) ? (String) current : null;
+  }
 }
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/library/src/test/groovy/io/opentelemetry/instrumentation/awssdk/v1_11/BedrockJsonParserTest.groovy b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/test/groovy/io/opentelemetry/instrumentation/awssdk/v1_11/BedrockJsonParserTest.groovy
new file mode 100644
index 0000000000..03563b1d5b
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/library/src/test/groovy/io/opentelemetry/instrumentation/awssdk/v1_11/BedrockJsonParserTest.groovy
@@ -0,0 +1,107 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v1_11
+
+import spock.lang.Specification
+
+class BedrockJsonParserTest extends Specification {
+  def "should parse simple JSON object"() {
+    given:
+    String json = '{"key":"value"}'
+
+    when:
+    def parsedJson = BedrockJsonParser.parse(json)
+
+    then:
+    parsedJson.getJsonBody() == [key: "value"]
+  }
+
+  def "should parse nested JSON object"() {
+    given:
+    String json = '{"parent":{"child":"value"}}'
+
+    when:
+    def parsedJson = BedrockJsonParser.parse(json)
+
+    then:
+    def parent = parsedJson.getJsonBody().get("parent")
+    parent instanceof Map
+    parent["child"] == "value"
+  }
+
+  def "should parse JSON array"() {
+    given:
+    String json = '{"array":[1, "two", 1.0]}'
+
+    when:
+    def parsedJson = BedrockJsonParser.parse(json)
+
+    then:
+    def array = parsedJson.getJsonBody().get("array")
+    array instanceof List
+    array == [1, "two", 1.0]
+  }
+
+  def "should parse escape sequences"() {
+    given:
+    String json = '{"escaped":"Line1\\nLine2\\tTabbed\\\"Quoted\\\"\\bBackspace\\fFormfeed\\rCarriageReturn\\\\Backslash\\/Slash\\u0041"}'
+
+    when:
+    def parsedJson = BedrockJsonParser.parse(json)
+
+    then:
+    parsedJson.getJsonBody().get("escaped") ==
+        "Line1\nLine2\tTabbed\"Quoted\"\bBackspace\fFormfeed\rCarriageReturn\\Backslash/SlashA"
+  }
+
+  def "should throw exception for malformed JSON"() {
+    given:
+    String malformedJson = '{"key":value}'
+
+    when:
+    BedrockJsonParser.parse(malformedJson)
+
+    then:
+    def ex = thrown(IllegalArgumentException)
+    ex.message.contains("Unexpected character")
+  }
+
+  def "should resolve path in JSON object"() {
+    given:
+    String json = '{"parent":{"child":{"key":"value"}}}'
+
+    when:
+    def parsedJson = BedrockJsonParser.parse(json)
+    def resolvedValue = BedrockJsonParser.JsonPathResolver.resolvePath(parsedJson, "/parent/child/key")
+
+    then:
+    resolvedValue == "value"
+  }
+
+  def "should resolve path in JSON array"() {
+    given:
+    String json = '{"array":[{"key":"value1"}, {"key":"value2"}]}'
+
+    when:
+    def parsedJson = BedrockJsonParser.parse(json)
+    def resolvedValue = BedrockJsonParser.JsonPathResolver.resolvePath(parsedJson, "/array/1/key")
+
+    then:
+    resolvedValue == "value2"
+  }
+
+  def "should return null for invalid path resolution"() {
+    given:
+    String json = '{"parent":{"child":{"key":"value"}}}'
+
+    when:
+    def parsedJson = BedrockJsonParser.parse(json)
+    def resolvedValue = BedrockJsonParser.JsonPathResolver.resolvePath(parsedJson, "/invalid/path")
+
+    then:
+    resolvedValue == null
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/build.gradle.kts b/instrumentation/aws-sdk/aws-sdk-1.11/testing/build.gradle.kts
index 545f5dffce..227a205ebd 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/testing/build.gradle.kts
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/build.gradle.kts
@@ -14,6 +14,14 @@ dependencies {
   compileOnly("com.amazonaws:aws-java-sdk-dynamodb:1.11.106")
   compileOnly("com.amazonaws:aws-java-sdk-sns:1.11.106")
   compileOnly("com.amazonaws:aws-java-sdk-sqs:1.11.106")
+  compileOnly("com.amazonaws:aws-java-sdk-secretsmanager:1.11.309")
+  compileOnly("com.amazonaws:aws-java-sdk-stepfunctions:1.11.230")
+  compileOnly("com.amazonaws:aws-java-sdk-lambda:1.11.678")
+
+  compileOnly("com.amazonaws:aws-java-sdk-bedrock:1.12.744")
+  compileOnly("com.amazonaws:aws-java-sdk-bedrockagent:1.12.744")
+  compileOnly("com.amazonaws:aws-java-sdk-bedrockagentruntime:1.12.744")
+  compileOnly("com.amazonaws:aws-java-sdk-bedrockruntime:1.12.744")
 
   // needed for SQS - using emq directly as localstack references emq v0.15.7 ie WITHOUT AWS trace header propagation
   implementation("org.elasticmq:elasticmq-rest-sqs_2.13")
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractBedrockAgentClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractBedrockAgentClientTest.java
new file mode 100644
index 0000000000..a5e5a63b09
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractBedrockAgentClientTest.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v1_11;
+
+import static io.opentelemetry.api.common.AttributeKey.stringKey;
+import static io.opentelemetry.sdk.testing.assertj.OpenTelemetryAssertions.equalTo;
+import static java.util.Collections.singletonList;
+
+import com.amazonaws.services.bedrockagent.AWSBedrockAgent;
+import com.amazonaws.services.bedrockagent.AWSBedrockAgentClientBuilder;
+import com.amazonaws.services.bedrockagent.model.GetAgentRequest;
+import com.amazonaws.services.bedrockagent.model.GetDataSourceRequest;
+import com.amazonaws.services.bedrockagent.model.GetKnowledgeBaseRequest;
+import io.opentelemetry.testing.internal.armeria.common.HttpResponse;
+import io.opentelemetry.testing.internal.armeria.common.HttpStatus;
+import io.opentelemetry.testing.internal.armeria.common.MediaType;
+import org.junit.jupiter.api.Test;
+
+public abstract class AbstractBedrockAgentClientTest extends AbstractBaseAwsClientTest {
+
+  public abstract AWSBedrockAgentClientBuilder configureClient(AWSBedrockAgentClientBuilder client);
+
+  @Override
+  protected boolean hasRequestId() {
+    return true;
+  }
+
+  @Test
+  public void sendGetAgentRequest() throws Exception {
+    AWSBedrockAgent client = createClient();
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.JSON_UTF_8, "{}"));
+
+    Object response = client.getAgent(new GetAgentRequest().withAgentId("agentId"));
+
+    assertRequestWithMockedResponse(
+        response,
+        client,
+        "AWSBedrockAgent",
+        "GetAgent",
+        "GET",
+        singletonList(equalTo(stringKey("aws.bedrock.agent.id"), "agentId")));
+  }
+
+  @Test
+  public void sendGetKnowledgeBaseRequest() throws Exception {
+    AWSBedrockAgent client = createClient();
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.JSON_UTF_8, "{}"));
+
+    Object response =
+        client.getKnowledgeBase(
+            new GetKnowledgeBaseRequest().withKnowledgeBaseId("knowledgeBaseId"));
+
+    assertRequestWithMockedResponse(
+        response,
+        client,
+        "AWSBedrockAgent",
+        "GetKnowledgeBase",
+        "GET",
+        singletonList(equalTo(stringKey("aws.bedrock.knowledge_base.id"), "knowledgeBaseId")));
+  }
+
+  @Test
+  public void sendGetDataSourceRequest() throws Exception {
+    AWSBedrockAgent client = createClient();
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.JSON_UTF_8, "{}"));
+
+    Object response =
+        client.getDataSource(
+            new GetDataSourceRequest()
+                .withDataSourceId("datasourceId")
+                .withKnowledgeBaseId("knowledgeBaseId"));
+
+    assertRequestWithMockedResponse(
+        response,
+        client,
+        "AWSBedrockAgent",
+        "GetDataSource",
+        "GET",
+        singletonList(equalTo(stringKey("aws.bedrock.data_source.id"), "datasourceId")));
+  }
+
+  private AWSBedrockAgent createClient() {
+    AWSBedrockAgentClientBuilder clientBuilder = AWSBedrockAgentClientBuilder.standard();
+    return configureClient(clientBuilder)
+        .withEndpointConfiguration(endpoint)
+        .withCredentials(credentialsProvider)
+        .build();
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractBedrockClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractBedrockClientTest.java
new file mode 100644
index 0000000000..a97b893055
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractBedrockClientTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v1_11;
+
+import static io.opentelemetry.api.common.AttributeKey.stringKey;
+import static io.opentelemetry.sdk.testing.assertj.OpenTelemetryAssertions.equalTo;
+import static java.util.Collections.singletonList;
+
+import com.amazonaws.services.bedrock.AmazonBedrock;
+import com.amazonaws.services.bedrock.AmazonBedrockClientBuilder;
+import com.amazonaws.services.bedrock.model.GetGuardrailRequest;
+import io.opentelemetry.testing.internal.armeria.common.HttpResponse;
+import io.opentelemetry.testing.internal.armeria.common.HttpStatus;
+import io.opentelemetry.testing.internal.armeria.common.MediaType;
+import org.junit.jupiter.api.Test;
+
+public abstract class AbstractBedrockClientTest extends AbstractBaseAwsClientTest {
+
+  public abstract AmazonBedrockClientBuilder configureClient(AmazonBedrockClientBuilder client);
+
+  @Override
+  protected boolean hasRequestId() {
+    return true;
+  }
+
+  @Test
+  public void sendRequestWithMockedResponse() throws Exception {
+    AmazonBedrockClientBuilder clientBuilder = AmazonBedrockClientBuilder.standard();
+    AmazonBedrock client =
+        configureClient(clientBuilder)
+            .withEndpointConfiguration(endpoint)
+            .withCredentials(credentialsProvider)
+            .build();
+
+    String body =
+        "{"
+            + "  \"blockedInputMessaging\": \"string\","
+            + "  \"blockedOutputsMessaging\": \"string\","
+            + "  \"contentPolicy\": {},"
+            + "  \"createdAt\": \"2024-06-12T18:31:45Z\","
+            + "  \"description\": \"string\","
+            + "  \"guardrailArn\": \"guardrailArn\","
+            + "  \"guardrailId\": \"guardrailId\","
+            + "  \"kmsKeyArn\": \"string\","
+            + "  \"name\": \"string\","
+            + "  \"sensitiveInformationPolicy\": {},"
+            + "  \"status\": \"READY\","
+            + "  \"topicPolicy\": {"
+            + "    \"topics\": ["
+            + "      {"
+            + "        \"definition\": \"string\","
+            + "        \"examples\": [ \"string\" ],"
+            + "        \"name\": \"string\","
+            + "        \"type\": \"string\""
+            + "      }"
+            + "    ]"
+            + "  },"
+            + "  \"updatedAt\": \"2024-06-12T18:31:48Z\","
+            + "  \"version\": \"DRAFT\","
+            + "  \"wordPolicy\": {}"
+            + "}";
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.JSON_UTF_8, body));
+
+    Object response =
+        client.getGuardrail(new GetGuardrailRequest().withGuardrailIdentifier("guardrailId"));
+
+    assertRequestWithMockedResponse(
+        response,
+        client,
+        "Bedrock",
+        "GetGuardrail",
+        "GET",
+        singletonList(equalTo(stringKey("aws.bedrock.guardrail.id"), "guardrailId")));
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractBedrockRuntimeClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractBedrockRuntimeClientTest.java
new file mode 100644
index 0000000000..98a5873614
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractBedrockRuntimeClientTest.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v1_11;
+
+import static io.opentelemetry.api.common.AttributeKey.stringKey;
+import static io.opentelemetry.sdk.testing.assertj.OpenTelemetryAssertions.equalTo;
+import static java.util.Arrays.asList;
+
+import com.amazonaws.services.bedrockruntime.AmazonBedrockRuntime;
+import com.amazonaws.services.bedrockruntime.AmazonBedrockRuntimeClientBuilder;
+import com.amazonaws.services.bedrockruntime.model.InvokeModelRequest;
+import io.opentelemetry.sdk.testing.assertj.AttributeAssertion;
+import io.opentelemetry.testing.internal.armeria.common.HttpResponse;
+import io.opentelemetry.testing.internal.armeria.common.HttpStatus;
+import io.opentelemetry.testing.internal.armeria.common.MediaType;
+import java.nio.charset.StandardCharsets;
+import java.util.List;
+import java.util.stream.Stream;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+public abstract class AbstractBedrockRuntimeClientTest extends AbstractBaseAwsClientTest {
+
+  public abstract AmazonBedrockRuntimeClientBuilder configureClient(
+      AmazonBedrockRuntimeClientBuilder client);
+
+  @Override
+  protected boolean hasRequestId() {
+    return true;
+  }
+
+  @ParameterizedTest
+  @MethodSource("testData")
+  public void sendRequestWithMockedResponse(
+      String modelId,
+      String requestBody,
+      String expectedResponse,
+      List<AttributeAssertion> expectedAttributes)
+      throws Exception {
+    AmazonBedrockRuntimeClientBuilder clientBuilder = AmazonBedrockRuntimeClientBuilder.standard();
+    AmazonBedrockRuntime client =
+        configureClient(clientBuilder)
+            .withEndpointConfiguration(endpoint)
+            .withCredentials(credentialsProvider)
+            .build();
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.JSON_UTF_8, expectedResponse));
+
+    client.invokeModel(
+        new InvokeModelRequest()
+            .withModelId(modelId)
+            .withBody(StandardCharsets.UTF_8.encode(requestBody)));
+
+    assertRequestWithMockedResponse(
+        expectedResponse, client, "BedrockRuntime", "InvokeModel", "POST", expectedAttributes);
+  }
+
+  private static Stream<Object[]> testData() {
+    return Stream.of(
+        new Object[] {
+          "ai21.jamba-1-5-mini-v1:0",
+          "{\"messages\":[{\"role\":\"user\",\"message\":\"Which LLM are you?\"}],\"max_tokens\":1000,\"top_p\":0.8,\"temperature\":0.7}",
+          "{\"choices\":[{\"finish_reason\":\"stop\"}],\"usage\":{\"prompt_tokens\":5,\"completion_tokens\":42}}",
+          asList(
+              equalTo(stringKey("gen_ai.request.model"), "ai21.jamba-1-5-mini-v1:0"),
+              equalTo(stringKey("gen_ai.system"), "aws.bedrock"),
+              equalTo(stringKey("gen_ai.request.max_tokens"), "1000"),
+              equalTo(stringKey("gen_ai.request.temperature"), "0.7"),
+              equalTo(stringKey("gen_ai.request.top_p"), "0.8"),
+              equalTo(stringKey("gen_ai.response.finish_reasons"), "[stop]"),
+              equalTo(stringKey("gen_ai.usage.input_tokens"), "5"),
+              equalTo(stringKey("gen_ai.usage.output_tokens"), "42"))
+        },
+        new Object[] {
+          "amazon.titan-text-premier-v1:0",
+          "{\"inputText\":\"Hello, world!\",\"textGenerationConfig\":{\"temperature\":0.7,\"topP\":0.9,\"maxTokenCount\":100,\"stopSequences\":[\"END\"]}}",
+          "{\"inputTextTokenCount\":5,\"results\":[{\"tokenCount\":42,\"outputText\":\"Hi! I'm Titan, an AI assistant.\",\"completionReason\":\"stop\"}]}",
+          asList(
+              equalTo(stringKey("gen_ai.request.model"), "amazon.titan-text-premier-v1:0"),
+              equalTo(stringKey("gen_ai.system"), "aws.bedrock"),
+              equalTo(stringKey("gen_ai.request.max_tokens"), "100"),
+              equalTo(stringKey("gen_ai.request.temperature"), "0.7"),
+              equalTo(stringKey("gen_ai.request.top_p"), "0.9"),
+              equalTo(stringKey("gen_ai.response.finish_reasons"), "[stop]"),
+              equalTo(stringKey("gen_ai.usage.input_tokens"), "5"),
+              equalTo(stringKey("gen_ai.usage.output_tokens"), "42"))
+        },
+        new Object[] {
+          "anthropic.claude-3-5-sonnet-20241022-v2:0",
+          "{\"anthropic_version\":\"bedrock-2023-05-31\",\"messages\":[{\"role\":\"user\",\"content\":\"Hello, world\"}],\"max_tokens\":100,\"temperature\":0.7,\"top_p\":0.9}",
+          "{\"stop_reason\":\"end_turn\",\"usage\":{\"input_tokens\":2095,\"output_tokens\":503}}",
+          asList(
+              equalTo(
+                  stringKey("gen_ai.request.model"), "anthropic.claude-3-5-sonnet-20241022-v2:0"),
+              equalTo(stringKey("gen_ai.system"), "aws.bedrock"),
+              equalTo(stringKey("gen_ai.request.max_tokens"), "100"),
+              equalTo(stringKey("gen_ai.request.temperature"), "0.7"),
+              equalTo(stringKey("gen_ai.request.top_p"), "0.9"),
+              equalTo(stringKey("gen_ai.response.finish_reasons"), "[end_turn]"),
+              equalTo(stringKey("gen_ai.usage.input_tokens"), "2095"),
+              equalTo(stringKey("gen_ai.usage.output_tokens"), "503"))
+        },
+        new Object[] {
+          "meta.llama3-70b-instruct-v1:0",
+          "{\"prompt\":\"<|begin_of_text|><|start_header_id|>user<|end_header_id|>\\\\nDescribe the purpose of a 'hello world' program in one line. <|eot_id|>\\\\n<|start_header_id|>assistant<|end_header_id|>\\\\n\",\"max_gen_len\":128,\"temperature\":0.1,\"top_p\":0.9}",
+          "{\"prompt_token_count\":2095,\"generation_token_count\":503,\"stop_reason\":\"stop\"}",
+          asList(
+              equalTo(stringKey("gen_ai.request.model"), "meta.llama3-70b-instruct-v1:0"),
+              equalTo(stringKey("gen_ai.system"), "aws.bedrock"),
+              equalTo(stringKey("gen_ai.request.max_tokens"), "128"),
+              equalTo(stringKey("gen_ai.request.temperature"), "0.1"),
+              equalTo(stringKey("gen_ai.request.top_p"), "0.9"),
+              equalTo(stringKey("gen_ai.response.finish_reasons"), "[stop]"),
+              equalTo(stringKey("gen_ai.usage.input_tokens"), "2095"),
+              equalTo(stringKey("gen_ai.usage.output_tokens"), "503"))
+        },
+        new Object[] {
+          "cohere.command-r-v1:0",
+          "{\"message\":\"Convince me to write a LISP interpreter in one line.\",\"temperature\":0.8,\"max_tokens\":4096,\"p\":0.45}",
+          "{\"text\":\"test-output\",\"finish_reason\":\"COMPLETE\"}",
+          asList(
+              equalTo(stringKey("gen_ai.request.model"), "cohere.command-r-v1:0"),
+              equalTo(stringKey("gen_ai.system"), "aws.bedrock"),
+              equalTo(stringKey("gen_ai.request.max_tokens"), "4096"),
+              equalTo(stringKey("gen_ai.request.temperature"), "0.8"),
+              equalTo(stringKey("gen_ai.request.top_p"), "0.45"),
+              equalTo(stringKey("gen_ai.response.finish_reasons"), "[COMPLETE]"),
+              equalTo(stringKey("gen_ai.usage.input_tokens"), "9"),
+              equalTo(stringKey("gen_ai.usage.output_tokens"), "2"))
+        });
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractDynamoDbClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractDynamoDbClientTest.java
index 441a4a3a0b..63156c88df 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractDynamoDbClientTest.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractDynamoDbClientTest.java
@@ -12,9 +12,12 @@ import static io.opentelemetry.semconv.incubating.DbIncubatingAttributes.DB_SYST
 import static io.opentelemetry.semconv.incubating.DbIncubatingAttributes.DbSystemIncubatingValues.DYNAMODB;
 import static java.util.Collections.singletonList;
 
+import static org.junit.Assert.assertEquals;
+
 import com.amazonaws.services.dynamodbv2.AmazonDynamoDB;
 import com.amazonaws.services.dynamodbv2.AmazonDynamoDBClientBuilder;
 import com.amazonaws.services.dynamodbv2.model.CreateTableRequest;
+import com.amazonaws.services.dynamodbv2.model.DescribeTableRequest;
 import io.opentelemetry.sdk.testing.assertj.AttributeAssertion;
 import io.opentelemetry.testing.internal.armeria.common.HttpResponse;
 import io.opentelemetry.testing.internal.armeria.common.HttpStatus;
@@ -53,4 +56,39 @@ public abstract class AbstractDynamoDbClientTest extends AbstractBaseAwsClientTe
     assertRequestWithMockedResponse(
         response, client, "DynamoDBv2", "CreateTable", "POST", additionalAttributes);
   }
+
+  @Test
+  public void testGetTableArnWithMockedResponse() {
+    AmazonDynamoDBClientBuilder clientBuilder = AmazonDynamoDBClientBuilder.standard();
+    AmazonDynamoDB client =
+        configureClient(clientBuilder)
+            .withEndpointConfiguration(endpoint)
+            .withCredentials(credentialsProvider)
+            .build();
+
+    String tableName = "MockTable";
+    String expectedArn = "arn:aws:dynamodb:us-west-2:123456789012:table/" + tableName;
+
+    String body =
+        "{\n"
+            + "\"Table\": {\n"
+            + "\"TableName\": \""
+            + tableName
+            + "\",\n"
+            + "\"TableArn\": \""
+            + expectedArn
+            + "\"\n"
+            + "}\n"
+            + "}";
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.JSON_UTF_8, body));
+
+    String actualArn =
+        client
+            .describeTable(new DescribeTableRequest().withTableName(tableName))
+            .getTable()
+            .getTableArn();
+
+    assertEquals("Table ARN should match expected value", expectedArn, actualArn);
+  }
 }
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractKinesisClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractKinesisClientTest.java
index ee6d1b7501..5fb8db3592 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractKinesisClientTest.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractKinesisClientTest.java
@@ -12,13 +12,16 @@ import static java.util.Collections.singletonList;
 import com.amazonaws.services.kinesis.AmazonKinesis;
 import com.amazonaws.services.kinesis.AmazonKinesisClientBuilder;
 import com.amazonaws.services.kinesis.model.DeleteStreamRequest;
+import com.amazonaws.services.kinesis.model.DescribeStreamRequest;
 import io.opentelemetry.sdk.testing.assertj.AttributeAssertion;
 import io.opentelemetry.testing.internal.armeria.common.HttpResponse;
 import io.opentelemetry.testing.internal.armeria.common.HttpStatus;
 import io.opentelemetry.testing.internal.armeria.common.MediaType;
+import java.util.Arrays;
 import java.util.List;
 import java.util.function.Function;
 import java.util.stream.Stream;
+import org.junit.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
@@ -54,6 +57,39 @@ public abstract class AbstractKinesisClientTest extends AbstractBaseAwsClientTes
         response, client, "Kinesis", operation, "POST", additionalAttributes);
   }
 
+  @Test
+  public void sendRequestWithStreamArnMockedResponse() throws Exception {
+    AmazonKinesisClientBuilder clientBuilder = AmazonKinesisClientBuilder.standard();
+    AmazonKinesis client =
+        configureClient(clientBuilder)
+            .withEndpointConfiguration(endpoint)
+            .withCredentials(credentialsProvider)
+            .build();
+
+    String body =
+        "{\n"
+            + "\"StreamDescription\": {\n"
+            + "\"StreamARN\": \"arn:aws:kinesis:us-east-1:123456789012:stream/somestream\",\n"
+            + "\"StreamName\": \"somestream\",\n"
+            + "\"StreamStatus\": \"ACTIVE\",\n"
+            + "\"Shards\": []\n"
+            + "}\n"
+            + "}";
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.JSON_UTF_8, body));
+
+    List<AttributeAssertion> additionalAttributes =
+        Arrays.asList(
+            equalTo(stringKey("aws.stream.name"), "somestream"),
+            equalTo(stringKey("aws.stream.arn"), "arn:aws:kinesis:us-east-1:123456789012:stream/somestream"));
+
+    Object response =
+        client.describeStream(new DescribeStreamRequest().withStreamName("somestream"));
+
+    assertRequestWithMockedResponse(
+        response, client, "Kinesis", "DescribeStream", "POST", additionalAttributes);
+  }
+
   private static Stream<Arguments> provideArguments() {
     return Stream.of(
         Arguments.of(
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractLambdaClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractLambdaClientTest.java
new file mode 100644
index 0000000000..9f5a245ee7
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractLambdaClientTest.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v1_11;
+
+import static io.opentelemetry.api.common.AttributeKey.stringKey;
+import static io.opentelemetry.sdk.testing.assertj.OpenTelemetryAssertions.equalTo;
+import static java.util.Collections.singletonList;
+
+import com.amazonaws.services.lambda.AWSLambda;
+import com.amazonaws.services.lambda.AWSLambdaClientBuilder;
+import com.amazonaws.services.lambda.model.GetEventSourceMappingRequest;
+import com.amazonaws.services.lambda.model.GetFunctionRequest;
+import io.opentelemetry.sdk.testing.assertj.AttributeAssertion;
+import io.opentelemetry.testing.internal.armeria.common.HttpResponse;
+import io.opentelemetry.testing.internal.armeria.common.HttpStatus;
+import io.opentelemetry.testing.internal.armeria.common.MediaType;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Stream;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+public abstract class AbstractLambdaClientTest extends AbstractBaseAwsClientTest {
+
+  public abstract AWSLambdaClientBuilder configureClient(AWSLambdaClientBuilder client);
+
+  @Override
+  protected boolean hasRequestId() {
+    return false;
+  }
+
+  @ParameterizedTest
+  @MethodSource("provideArguments")
+  public void testSendRequestWithMockedResponse(
+      String operation,
+      List<AttributeAssertion> additionalAttributes,
+      Function<AWSLambda, Object> call)
+      throws Exception {
+
+    AWSLambdaClientBuilder clientBuilder = AWSLambdaClientBuilder.standard();
+
+    AWSLambda client =
+        configureClient(clientBuilder)
+            .withEndpointConfiguration(endpoint)
+            .withCredentials(credentialsProvider)
+            .build();
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, ""));
+
+    Object response = call.apply(client);
+    assertRequestWithMockedResponse(
+        response, client, "AWSLambda", operation, "GET", additionalAttributes);
+  }
+
+  private static Stream<Arguments> provideArguments() {
+    return Stream.of(
+        Arguments.of(
+            "GetEventSourceMapping",
+            singletonList(equalTo(stringKey("aws.lambda.resource_mapping.id"), "uuid")),
+            (Function<AWSLambda, Object>)
+                c -> c.getEventSourceMapping(new GetEventSourceMappingRequest().withUUID("uuid"))),
+        Arguments.of(
+            "GetFunction",
+            singletonList(equalTo(stringKey("aws.lambda.function.name"), "functionName")),
+            (Function<AWSLambda, Object>)
+                c -> c.getFunction(new GetFunctionRequest().withFunctionName("functionName"))));
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractS3ClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractS3ClientTest.java
index 574165992f..5248d050b6 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractS3ClientTest.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractS3ClientTest.java
@@ -175,6 +175,7 @@ public abstract class AbstractS3ClientTest extends AbstractBaseAwsClientTest {
                                 equalTo(RPC_SYSTEM, "aws-api"),
                                 equalTo(RPC_SERVICE, "Amazon S3"),
                                 equalTo(RPC_METHOD, "GetObject"),
+                                equalTo(stringKey("aws.auth.account.access_key"), "my-access-key"),
                                 equalTo(stringKey("aws.endpoint"), server.httpUri().toString()),
                                 equalTo(stringKey("aws.agent"), "java-aws-sdk"),
                                 equalTo(stringKey("aws.bucket.name"), "someBucket"),
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractSecretsManagerClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractSecretsManagerClientTest.java
new file mode 100644
index 0000000000..03de6fce3f
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractSecretsManagerClientTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v1_11;
+
+import static io.opentelemetry.api.common.AttributeKey.stringKey;
+import static io.opentelemetry.sdk.testing.assertj.OpenTelemetryAssertions.equalTo;
+import static java.util.Collections.singletonList;
+
+import com.amazonaws.services.secretsmanager.AWSSecretsManager;
+import com.amazonaws.services.secretsmanager.AWSSecretsManagerClientBuilder;
+import com.amazonaws.services.secretsmanager.model.CreateSecretRequest;
+import io.opentelemetry.testing.internal.armeria.common.HttpResponse;
+import io.opentelemetry.testing.internal.armeria.common.HttpStatus;
+import io.opentelemetry.testing.internal.armeria.common.MediaType;
+import org.junit.jupiter.api.Test;
+
+public abstract class AbstractSecretsManagerClientTest extends AbstractBaseAwsClientTest {
+
+  public abstract AWSSecretsManagerClientBuilder configureClient(
+      AWSSecretsManagerClientBuilder client);
+
+  @Override
+  protected boolean hasRequestId() {
+    return true;
+  }
+
+  @Test
+  public void sendRequestWithMockedResponse() throws Exception {
+    AWSSecretsManagerClientBuilder clientBuilder = AWSSecretsManagerClientBuilder.standard();
+    AWSSecretsManager client =
+        configureClient(clientBuilder)
+            .withEndpointConfiguration(endpoint)
+            .withCredentials(credentialsProvider)
+            .build();
+
+    String body =
+        "{"
+            + "\"ARN\": \"arn:aws:secretsmanager:us-west-2:123456789012:secret:MyTestDatabaseSecret-a1b2c3\","
+            + "\"Name\": \"MyTestDatabaseSecret\","
+            + "\"VersionId\": \"EXAMPLE1-90ab-cdef-fedc-ba987SECRET1\""
+            + "}";
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, body));
+
+    Object response =
+        client.createSecret(
+            new CreateSecretRequest().withName("secretName").withSecretString("secretValue"));
+
+    assertRequestWithMockedResponse(
+        response,
+        client,
+        "AWSSecretsManager",
+        "CreateSecret",
+        "POST",
+        singletonList(
+            equalTo(
+                stringKey("aws.secretsmanager.secret.arn"),
+                "arn:aws:secretsmanager:us-west-2:123456789012:secret:MyTestDatabaseSecret-a1b2c3")));
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractSnsClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractSnsClientTest.java
index 3f272ba477..bea20f3d86 100644
--- a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractSnsClientTest.java
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractSnsClientTest.java
@@ -5,8 +5,10 @@
 
 package io.opentelemetry.instrumentation.awssdk.v1_11;
 
+import static io.opentelemetry.api.common.AttributeKey.stringKey;
 import static io.opentelemetry.sdk.testing.assertj.OpenTelemetryAssertions.equalTo;
 import static io.opentelemetry.semconv.incubating.MessagingIncubatingAttributes.MESSAGING_DESTINATION_NAME;
+import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
 
 import com.amazonaws.services.sns.AmazonSNS;
@@ -17,11 +19,7 @@ import io.opentelemetry.testing.internal.armeria.common.HttpResponse;
 import io.opentelemetry.testing.internal.armeria.common.HttpStatus;
 import io.opentelemetry.testing.internal.armeria.common.MediaType;
 import java.util.List;
-import java.util.function.Function;
-import java.util.stream.Stream;
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.Arguments;
-import org.junit.jupiter.params.provider.MethodSource;
+import org.junit.jupiter.api.Test;
 
 public abstract class AbstractSnsClientTest extends AbstractBaseAwsClientTest {
 
@@ -32,9 +30,8 @@ public abstract class AbstractSnsClientTest extends AbstractBaseAwsClientTest {
     return true;
   }
 
-  @ParameterizedTest
-  @MethodSource("provideArguments")
-  public void testSendRequestWithMockedResponse(Function<AmazonSNS, Object> call) throws Exception {
+  @Test
+  public void testSendRequestWithwithTopicArnMockedResponse() throws Exception {
     AmazonSNSClientBuilder clientBuilder = AmazonSNSClientBuilder.standard();
     AmazonSNS client =
         configureClient(clientBuilder)
@@ -55,24 +52,44 @@ public abstract class AbstractSnsClientTest extends AbstractBaseAwsClientTest {
     server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, body));
 
     List<AttributeAssertion> additionalAttributes =
-        singletonList(equalTo(MESSAGING_DESTINATION_NAME, "somearn"));
+        asList(
+            equalTo(stringKey(MESSAGING_DESTINATION_NAME.getKey()), "somearn"),
+            equalTo(stringKey("aws.sns.topic.arn"), "somearn"));
+
+    Object response =
+        client.publish(new PublishRequest().withMessage("somemessage").withTopicArn("somearn"));
 
-    Object response = call.apply(client);
     assertRequestWithMockedResponse(
         response, client, "SNS", "Publish", "POST", additionalAttributes);
   }
 
-  private static Stream<Arguments> provideArguments() {
-    return Stream.of(
-        Arguments.of(
-            (Function<AmazonSNS, Object>)
-                c ->
-                    c.publish(
-                        new PublishRequest().withMessage("somemessage").withTopicArn("somearn"))),
-        Arguments.of(
-            (Function<AmazonSNS, Object>)
-                c ->
-                    c.publish(
-                        new PublishRequest().withMessage("somemessage").withTargetArn("somearn"))));
+  @Test
+  public void testSendRequestWithwithTargetArnMockedResponse() throws Exception {
+    AmazonSNSClientBuilder clientBuilder = AmazonSNSClientBuilder.standard();
+    AmazonSNS client =
+        configureClient(clientBuilder)
+            .withEndpointConfiguration(endpoint)
+            .withCredentials(credentialsProvider)
+            .build();
+
+    String body =
+        "<PublishResponse xmlns=\"https://sns.amazonaws.com/doc/2010-03-31/\">"
+            + "    <PublishResult>"
+            + "        <MessageId>567910cd-659e-55d4-8ccb-5aaf14679dc0</MessageId>"
+            + "    </PublishResult>"
+            + "    <ResponseMetadata>"
+            + "        <RequestId>d74b8436-ae13-5ab4-a9ff-ce54dfea72a0</RequestId>"
+            + "    </ResponseMetadata>"
+            + "</PublishResponse>";
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, body));
+
+    List<AttributeAssertion> additionalAttributes =
+        singletonList(equalTo(stringKey(MESSAGING_DESTINATION_NAME.getKey()), "somearn"));
+
+    Object response =
+        client.publish(new PublishRequest().withMessage("somemessage").withTargetArn("somearn"));
+    assertRequestWithMockedResponse(
+        response, client, "SNS", "Publish", "POST", additionalAttributes);
   }
 }
diff --git a/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractStepFunctionsClientTest.java b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractStepFunctionsClientTest.java
new file mode 100644
index 0000000000..fc58ec3c9b
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-1.11/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v1_11/AbstractStepFunctionsClientTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v1_11;
+
+import static io.opentelemetry.api.common.AttributeKey.stringKey;
+import static io.opentelemetry.sdk.testing.assertj.OpenTelemetryAssertions.equalTo;
+import static java.util.Collections.singletonList;
+
+import com.amazonaws.services.stepfunctions.AWSStepFunctions;
+import com.amazonaws.services.stepfunctions.AWSStepFunctionsClientBuilder;
+import com.amazonaws.services.stepfunctions.model.DescribeActivityRequest;
+import com.amazonaws.services.stepfunctions.model.DescribeStateMachineRequest;
+import io.opentelemetry.sdk.testing.assertj.AttributeAssertion;
+import io.opentelemetry.testing.internal.armeria.common.HttpResponse;
+import io.opentelemetry.testing.internal.armeria.common.HttpStatus;
+import io.opentelemetry.testing.internal.armeria.common.MediaType;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Stream;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+public abstract class AbstractStepFunctionsClientTest extends AbstractBaseAwsClientTest {
+
+  public abstract AWSStepFunctionsClientBuilder configureClient(
+      AWSStepFunctionsClientBuilder client);
+
+  @Override
+  protected boolean hasRequestId() {
+    return false;
+  }
+
+  @ParameterizedTest
+  @MethodSource("provideArguments")
+  public void testSendRequestWithMockedResponse(
+      String operation,
+      List<AttributeAssertion> additionalAttributes,
+      Function<AWSStepFunctions, Object> call)
+      throws Exception {
+
+    AWSStepFunctionsClientBuilder clientBuilder = AWSStepFunctionsClientBuilder.standard();
+
+    AWSStepFunctions client =
+        configureClient(clientBuilder)
+            .withEndpointConfiguration(endpoint)
+            .withCredentials(credentialsProvider)
+            .build();
+
+    server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, ""));
+
+    Object response = call.apply(client);
+    assertRequestWithMockedResponse(
+        response, client, "AWSStepFunctions", operation, "POST", additionalAttributes);
+  }
+
+  private static Stream<Arguments> provideArguments() {
+    return Stream.of(
+        Arguments.of(
+            "DescribeStateMachine",
+            singletonList(
+                equalTo(stringKey("aws.stepfunctions.state_machine.arn"), "stateMachineArn")),
+            (Function<AWSStepFunctions, Object>)
+                c ->
+                    c.describeStateMachine(
+                        new DescribeStateMachineRequest().withStateMachineArn("stateMachineArn"))),
+        Arguments.of(
+            "DescribeActivity",
+            singletonList(equalTo(stringKey("aws.stepfunctions.activity.arn"), "activityArn")),
+            (Function<AWSStepFunctions, Object>)
+                c ->
+                    c.describeActivity(
+                        new DescribeActivityRequest().withActivityArn("activityArn"))));
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/javaagent/build.gradle.kts b/instrumentation/aws-sdk/aws-sdk-2.2/javaagent/build.gradle.kts
index 7d3fa5d03c..6079232826 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/javaagent/build.gradle.kts
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/javaagent/build.gradle.kts
@@ -104,6 +104,9 @@ dependencies {
   testLibrary("software.amazon.awssdk:sqs:2.2.0")
   testLibrary("software.amazon.awssdk:sns:2.2.0")
   testLibrary("software.amazon.awssdk:ses:2.2.0")
+  testLibrary("software.amazon.awssdk:sfn:2.2.0")
+  testLibrary("software.amazon.awssdk:secretsmanager:2.2.0")
+  testLibrary("software.amazon.awssdk:lambda:2.2.0")
 }
 
 val latestDepTest = findProperty("testLatestDeps") as Boolean
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library-autoconfigure/build.gradle.kts b/instrumentation/aws-sdk/aws-sdk-2.2/library-autoconfigure/build.gradle.kts
index d493f83a86..0bb91a17c3 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/library-autoconfigure/build.gradle.kts
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library-autoconfigure/build.gradle.kts
@@ -22,6 +22,9 @@ dependencies {
   testLibrary("software.amazon.awssdk:s3:2.2.0")
   testLibrary("software.amazon.awssdk:sqs:2.2.0")
   testLibrary("software.amazon.awssdk:sns:2.2.0")
+  testLibrary("software.amazon.awssdk:sfn:2.2.0")
+  testLibrary("software.amazon.awssdk:secretsmanager:2.2.0")
+  testLibrary("software.amazon.awssdk:lambda:2.2.0")
 }
 
 tasks {
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library/build.gradle.kts b/instrumentation/aws-sdk/aws-sdk-2.2/library/build.gradle.kts
index 3b7381a8ba..6f77951710 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/library/build.gradle.kts
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library/build.gradle.kts
@@ -22,6 +22,9 @@ dependencies {
   testLibrary("software.amazon.awssdk:rds:2.2.0")
   testLibrary("software.amazon.awssdk:s3:2.2.0")
   testLibrary("software.amazon.awssdk:ses:2.2.0")
+  testLibrary("software.amazon.awssdk:sfn:2.2.0")
+  testLibrary("software.amazon.awssdk:secretsmanager:2.2.0")
+  testLibrary("software.amazon.awssdk:lambda:2.2.0")
 }
 
 testing {
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsExperimentalAttributes.java b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsExperimentalAttributes.java
new file mode 100644
index 0000000000..fd951ffe37
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsExperimentalAttributes.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v2_2.internal;
+
+import static io.opentelemetry.api.common.AttributeKey.stringKey;
+
+import io.opentelemetry.api.common.AttributeKey;
+
+final class AwsExperimentalAttributes {
+  static final AttributeKey<String> AWS_BUCKET_NAME = stringKey("aws.bucket.name");
+  static final AttributeKey<String> AWS_QUEUE_URL = stringKey("aws.queue.url");
+  static final AttributeKey<String> AWS_QUEUE_NAME = stringKey("aws.queue.name");
+  static final AttributeKey<String> AWS_STREAM_NAME = stringKey("aws.stream.name");
+  static final AttributeKey<String> AWS_STREAM_ARN = stringKey("aws.stream.arn");
+  static final AttributeKey<String> AWS_TABLE_NAME = stringKey("aws.table.name");
+  static final AttributeKey<String> AWS_GUARDRAIL_ID = stringKey("aws.bedrock.guardrail.id");
+  static final AttributeKey<String> AWS_GUARDRAIL_ARN = stringKey("aws.bedrock.guardrail.arn");
+  static final AttributeKey<String> AWS_AGENT_ID = stringKey("aws.bedrock.agent.id");
+  static final AttributeKey<String> AWS_DATA_SOURCE_ID = stringKey("aws.bedrock.data_source.id");
+  static final AttributeKey<String> AWS_KNOWLEDGE_BASE_ID =
+      stringKey("aws.bedrock.knowledge_base.id");
+
+  // TODO: Merge in gen_ai attributes in opentelemetry-semconv-incubating once upgrade to v1.26.0
+  static final AttributeKey<String> GEN_AI_MODEL = stringKey("gen_ai.request.model");
+  static final AttributeKey<String> GEN_AI_SYSTEM = stringKey("gen_ai.system");
+
+  static final AttributeKey<String> GEN_AI_REQUEST_MAX_TOKENS =
+      stringKey("gen_ai.request.max_tokens");
+
+  static final AttributeKey<String> GEN_AI_REQUEST_TEMPERATURE =
+      stringKey("gen_ai.request.temperature");
+
+  static final AttributeKey<String> GEN_AI_REQUEST_TOP_P = stringKey("gen_ai.request.top_p");
+
+  static final AttributeKey<String> GEN_AI_RESPONSE_FINISH_REASONS =
+      stringKey("gen_ai.response.finish_reasons");
+
+  static final AttributeKey<String> GEN_AI_USAGE_INPUT_TOKENS =
+      stringKey("gen_ai.usage.input_tokens");
+
+  static final AttributeKey<String> GEN_AI_USAGE_OUTPUT_TOKENS =
+      stringKey("gen_ai.usage.output_tokens");
+
+  static final AttributeKey<String> AWS_STATE_MACHINE_ARN =
+      stringKey("aws.stepfunctions.state_machine.arn");
+
+  static final AttributeKey<String> AWS_STEP_FUNCTIONS_ACTIVITY_ARN =
+      stringKey("aws.stepfunctions.activity.arn");
+
+  static final AttributeKey<String> AWS_SNS_TOPIC_ARN = stringKey("aws.sns.topic.arn");
+
+  static final AttributeKey<String> AWS_SECRET_ARN = stringKey("aws.secretsmanager.secret.arn");
+
+  static final AttributeKey<String> AWS_LAMBDA_NAME = stringKey("aws.lambda.function.name");
+
+  static final AttributeKey<String> AWS_LAMBDA_ARN = stringKey("aws.lambda.function.arn");
+
+  static final AttributeKey<String> AWS_LAMBDA_RESOURCE_ID =
+      stringKey("aws.lambda.resource_mapping.id");
+
+  static final AttributeKey<String> AWS_TABLE_ARN = stringKey("aws.table.arn");
+
+  static final AttributeKey<String> AWS_AUTH_ACCESS_KEY = stringKey("aws.auth.account.access_key");
+
+  static final AttributeKey<String> AWS_AUTH_REGION = stringKey("aws.auth.region");
+
+  static boolean isGenAiAttribute(String attributeKey) {
+    return attributeKey.equals(GEN_AI_REQUEST_MAX_TOKENS.getKey())
+        || attributeKey.equals(GEN_AI_REQUEST_TEMPERATURE.getKey())
+        || attributeKey.equals(GEN_AI_REQUEST_TOP_P.getKey())
+        || attributeKey.equals(GEN_AI_RESPONSE_FINISH_REASONS.getKey())
+        || attributeKey.equals(GEN_AI_USAGE_INPUT_TOKENS.getKey())
+        || attributeKey.equals(GEN_AI_USAGE_OUTPUT_TOKENS.getKey());
+  }
+
+  private AwsExperimentalAttributes() {}
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsSdkRequest.java b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsSdkRequest.java
index 02d92ca070..aa98cd62c7 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsSdkRequest.java
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsSdkRequest.java
@@ -5,11 +5,20 @@
 
 package io.opentelemetry.instrumentation.awssdk.v2_2.internal;
 
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.BEDROCK;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.BEDROCKAGENTOPERATION;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.BEDROCKAGENTRUNTIMEOPERATION;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.BEDROCKDATASOURCEOPERATION;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.BEDROCKKNOWLEDGEBASEOPERATION;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.BEDROCKRUNTIME;
 import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.DYNAMODB;
 import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.KINESIS;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.LAMBDA;
 import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.S3;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.SECRETSMANAGER;
 import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.SNS;
 import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.SQS;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.STEPFUNCTION;
 import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.FieldMapping.request;
 import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.FieldMapping.response;
 
@@ -34,6 +43,52 @@ enum AwsSdkRequest {
   SnsRequest(SNS, "SnsRequest"),
   SqsRequest(SQS, "SqsRequest"),
   KinesisRequest(KINESIS, "KinesisRequest"),
+
+  BedrockRequest(BEDROCK, "BedrockRequest"),
+  BedrockAgentRuntimeRequest(BEDROCKAGENTRUNTIMEOPERATION, "BedrockAgentRuntimeRequest"),
+  BedrockRuntimeRequest(BEDROCKRUNTIME, "BedrockRuntimeRequest"),
+  // BedrockAgent API based requests. We only support operations that are related to
+  // Agent/DataSources/KnowledgeBases
+  // resources and the request/response context contains the resource ID.
+  BedrockCreateAgentActionGroupRequest(BEDROCKAGENTOPERATION, "CreateAgentActionGroupRequest"),
+  BedrockCreateAgentAliasRequest(BEDROCKAGENTOPERATION, "CreateAgentAliasRequest"),
+  BedrockDeleteAgentActionGroupRequest(BEDROCKAGENTOPERATION, "DeleteAgentActionGroupRequest"),
+  BedrockDeleteAgentAliasRequest(BEDROCKAGENTOPERATION, "DeleteAgentAliasRequest"),
+  BedrockDeleteAgentVersionRequest(BEDROCKAGENTOPERATION, "DeleteAgentVersionRequest"),
+  BedrockGetAgentActionGroupRequest(BEDROCKAGENTOPERATION, "GetAgentActionGroupRequest"),
+  BedrockGetAgentAliasRequest(BEDROCKAGENTOPERATION, "GetAgentAliasRequest"),
+  BedrockGetAgentRequest(BEDROCKAGENTOPERATION, "GetAgentRequest"),
+  BedrockGetAgentVersionRequest(BEDROCKAGENTOPERATION, "GetAgentVersionRequest"),
+  BedrockListAgentActionGroupsRequest(BEDROCKAGENTOPERATION, "ListAgentActionGroupsRequest"),
+  BedrockListAgentAliasesRequest(BEDROCKAGENTOPERATION, "ListAgentAliasesRequest"),
+  BedrockListAgentKnowledgeBasesRequest(BEDROCKAGENTOPERATION, "ListAgentKnowledgeBasesRequest"),
+  BedrocListAgentVersionsRequest(BEDROCKAGENTOPERATION, "ListAgentVersionsRequest"),
+  BedrockPrepareAgentRequest(BEDROCKAGENTOPERATION, "PrepareAgentRequest"),
+  BedrockUpdateAgentActionGroupRequest(BEDROCKAGENTOPERATION, "UpdateAgentActionGroupRequest"),
+  BedrockUpdateAgentAliasRequest(BEDROCKAGENTOPERATION, "UpdateAgentAliasRequest"),
+  BedrockUpdateAgentRequest(BEDROCKAGENTOPERATION, "UpdateAgentRequest"),
+  BedrockBedrockAgentRequest(BEDROCKAGENTOPERATION, "BedrockAgentRequest"),
+  BedrockDeleteDataSourceRequest(BEDROCKDATASOURCEOPERATION, "DeleteDataSourceRequest"),
+  BedrockGetDataSourceRequest(BEDROCKDATASOURCEOPERATION, "GetDataSourceRequest"),
+  BedrockUpdateDataSourceRequest(BEDROCKDATASOURCEOPERATION, "UpdateDataSourceRequest"),
+  BedrocAssociateAgentKnowledgeBaseRequest(
+      BEDROCKKNOWLEDGEBASEOPERATION, "AssociateAgentKnowledgeBaseRequest"),
+  BedrockCreateDataSourceRequest(BEDROCKKNOWLEDGEBASEOPERATION, "CreateDataSourceRequest"),
+  BedrockDeleteKnowledgeBaseRequest(BEDROCKKNOWLEDGEBASEOPERATION, "DeleteKnowledgeBaseRequest"),
+  BedrockDisassociateAgentKnowledgeBaseRequest(
+      BEDROCKKNOWLEDGEBASEOPERATION, "DisassociateAgentKnowledgeBaseRequest"),
+  BedrockGetAgentKnowledgeBaseRequest(
+      BEDROCKKNOWLEDGEBASEOPERATION, "GetAgentKnowledgeBaseRequest"),
+  BedrockGetKnowledgeBaseRequest(BEDROCKKNOWLEDGEBASEOPERATION, "GetKnowledgeBaseRequest"),
+  BedrockListDataSourcesRequest(BEDROCKKNOWLEDGEBASEOPERATION, "ListDataSourcesRequest"),
+  BedrockUpdateAgentKnowledgeBaseRequest(
+      BEDROCKKNOWLEDGEBASEOPERATION, "UpdateAgentKnowledgeBaseRequest"),
+
+  SfnRequest(STEPFUNCTION, "SfnRequest"),
+
+  SecretsManagerRequest(SECRETSMANAGER, "SecretsManagerRequest"),
+
+  LambdaRequest(LAMBDA, "LambdaRequest"),
   // specific requests
   BatchGetItem(
       DYNAMODB,
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsSdkRequestType.java b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsSdkRequestType.java
index 274ec27194..d8dba6cf5c 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsSdkRequestType.java
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/AwsSdkRequestType.java
@@ -5,7 +5,34 @@
 
 package io.opentelemetry.instrumentation.awssdk.v2_2.internal;
 
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_AGENT_ID;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_BUCKET_NAME;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_DATA_SOURCE_ID;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_GUARDRAIL_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_GUARDRAIL_ID;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_KNOWLEDGE_BASE_ID;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_LAMBDA_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_LAMBDA_NAME;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_LAMBDA_RESOURCE_ID;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_QUEUE_NAME;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_QUEUE_URL;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_SECRET_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_SNS_TOPIC_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_STATE_MACHINE_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_STEP_FUNCTIONS_ACTIVITY_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_STREAM_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_STREAM_NAME;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_TABLE_ARN;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_TABLE_NAME;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.GEN_AI_MODEL;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.GEN_AI_REQUEST_MAX_TOKENS;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.GEN_AI_REQUEST_TEMPERATURE;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.GEN_AI_REQUEST_TOP_P;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.GEN_AI_RESPONSE_FINISH_REASONS;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.GEN_AI_USAGE_INPUT_TOKENS;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.GEN_AI_USAGE_OUTPUT_TOKENS;
 import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.FieldMapping.request;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.FieldMapping.response;
 
 import io.opentelemetry.api.common.AttributeKey;
 import java.util.Collections;
@@ -13,16 +40,64 @@ import java.util.List;
 import java.util.Map;
 
 enum AwsSdkRequestType {
-  S3(request("aws.bucket.name", "Bucket")),
-  SQS(request("aws.queue.url", "QueueUrl"), request("aws.queue.name", "QueueName")),
-  KINESIS(request("aws.stream.name", "StreamName")),
-  DYNAMODB(request("aws.table.name", "TableName")),
+  S3(request(AWS_BUCKET_NAME.getKey(), "Bucket")),
+
+  SQS(request(AWS_QUEUE_URL.getKey(), "QueueUrl"), request(AWS_QUEUE_NAME.getKey(), "QueueName")),
+
+  KINESIS(
+      request(AWS_STREAM_NAME.getKey(), "StreamName"),
+      request(AWS_STREAM_ARN.getKey(), "StreamARN")),
+
+  DYNAMODB(
+      request(AWS_TABLE_NAME.getKey(), "TableName"),
+      response(AWS_TABLE_ARN.getKey(), "Table.TableArn")),
+
   SNS(
       /*
        * Only one of TopicArn and TargetArn are permitted on an SNS request.
        */
       request(AttributeKeys.MESSAGING_DESTINATION_NAME.getKey(), "TargetArn"),
-      request(AttributeKeys.MESSAGING_DESTINATION_NAME.getKey(), "TopicArn"));
+      request(AttributeKeys.MESSAGING_DESTINATION_NAME.getKey(), "TopicArn"),
+      request(AWS_SNS_TOPIC_ARN.getKey(), "TopicArn")),
+
+  BEDROCK(
+      request(AWS_GUARDRAIL_ID.getKey(), "guardrailIdentifier"),
+      response(AWS_GUARDRAIL_ARN.getKey(), "guardrailArn")),
+  BEDROCKAGENTOPERATION(
+      request(AWS_AGENT_ID.getKey(), "agentId"), response(AWS_AGENT_ID.getKey(), "agentId")),
+  BEDROCKAGENTRUNTIMEOPERATION(
+      request(AWS_AGENT_ID.getKey(), "agentId"),
+      response(AWS_AGENT_ID.getKey(), "agentId"),
+      request(AWS_KNOWLEDGE_BASE_ID.getKey(), "knowledgeBaseId"),
+      response(AWS_KNOWLEDGE_BASE_ID.getKey(), "knowledgeBaseId")),
+  BEDROCKDATASOURCEOPERATION(
+      request(AWS_DATA_SOURCE_ID.getKey(), "dataSourceId"),
+      response(AWS_DATA_SOURCE_ID.getKey(), "dataSourceId")),
+  BEDROCKKNOWLEDGEBASEOPERATION(
+      request(AWS_KNOWLEDGE_BASE_ID.getKey(), "knowledgeBaseId"),
+      response(AWS_KNOWLEDGE_BASE_ID.getKey(), "knowledgeBaseId")),
+  BEDROCKRUNTIME(
+      request(GEN_AI_MODEL.getKey(), "modelId"),
+      request(GEN_AI_REQUEST_MAX_TOKENS.getKey(), "body"),
+      request(GEN_AI_REQUEST_TEMPERATURE.getKey(), "body"),
+      request(GEN_AI_REQUEST_TOP_P.getKey(), "body"),
+      request(GEN_AI_USAGE_INPUT_TOKENS.getKey(), "body"),
+      response(GEN_AI_RESPONSE_FINISH_REASONS.getKey(), "body"),
+      response(GEN_AI_USAGE_INPUT_TOKENS.getKey(), "body"),
+      response(GEN_AI_USAGE_OUTPUT_TOKENS.getKey(), "body")),
+
+  STEPFUNCTION(
+      request(AWS_STATE_MACHINE_ARN.getKey(), "stateMachineArn"),
+      request(AWS_STEP_FUNCTIONS_ACTIVITY_ARN.getKey(), "activityArn")),
+
+  //  SNS(request(AWS_SNS_TOPIC_ARN.getKey(), "TopicArn")),
+
+  SECRETSMANAGER(response(AWS_SECRET_ARN.getKey(), "ARN")),
+
+  LAMBDA(
+      request(AWS_LAMBDA_NAME.getKey(), "FunctionName"),
+      request(AWS_LAMBDA_RESOURCE_ID.getKey(), "UUID"),
+      response(AWS_LAMBDA_ARN.getKey(), "Configuration.FunctionArn"));
 
   // Wrapping in unmodifiableMap
   @SuppressWarnings("ImmutableEnumChecker")
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/BedrockJsonParser.java b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/BedrockJsonParser.java
new file mode 100644
index 0000000000..9812f1afa5
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/BedrockJsonParser.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v2_2.internal;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * This class is internal and is hence not for public use. Its APIs are unstable and can change at
+ * any time.
+ */
+public class BedrockJsonParser {
+
+  // Prevent instantiation
+  private BedrockJsonParser() {
+    throw new UnsupportedOperationException("Utility class");
+  }
+
+  /**
+   * This class is internal and is hence not for public use. Its APIs are unstable and can change at
+   * any time.
+   */
+  public static LlmJson parse(String jsonString) {
+    JsonParser parser = new JsonParser(jsonString);
+    Map<String, Object> jsonBody = parser.parse();
+    return new LlmJson(jsonBody);
+  }
+
+  static class JsonParser {
+    private final String json;
+    private int position;
+
+    public JsonParser(String json) {
+      this.json = json.trim();
+      this.position = 0;
+    }
+
+    private void skipWhitespace() {
+      while (position < json.length() && Character.isWhitespace(json.charAt(position))) {
+        position++;
+      }
+    }
+
+    private char currentChar() {
+      return json.charAt(position);
+    }
+
+    private static boolean isHexDigit(char c) {
+      return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
+    }
+
+    private void expect(char c) {
+      skipWhitespace();
+      if (currentChar() != c) {
+        throw new IllegalArgumentException(
+            "Expected '" + c + "' but found '" + currentChar() + "'");
+      }
+      position++;
+    }
+
+    private String readString() {
+      skipWhitespace();
+      expect('"'); // Ensure the string starts with a quote
+      StringBuilder result = new StringBuilder();
+      while (currentChar() != '"') {
+        // Handle escape sequences
+        if (currentChar() == '\\') {
+          position++; // Move past the backslash
+          if (position >= json.length()) {
+            throw new IllegalArgumentException("Unexpected end of input in string escape sequence");
+          }
+          char escapeChar = currentChar();
+          switch (escapeChar) {
+            case '"':
+            case '\\':
+            case '/':
+              result.append(escapeChar);
+              break;
+            case 'b':
+              result.append('\b');
+              break;
+            case 'f':
+              result.append('\f');
+              break;
+            case 'n':
+              result.append('\n');
+              break;
+            case 'r':
+              result.append('\r');
+              break;
+            case 't':
+              result.append('\t');
+              break;
+            case 'u': // Unicode escape sequence
+              if (position + 4 >= json.length()) {
+                throw new IllegalArgumentException("Invalid unicode escape sequence in string");
+              }
+              char[] hexChars = new char[4];
+              for (int i = 0; i < 4; i++) {
+                position++; // Move to the next character
+                char hexChar = json.charAt(position);
+                if (!isHexDigit(hexChar)) {
+                  throw new IllegalArgumentException(
+                      "Invalid hexadecimal digit in unicode escape sequence");
+                }
+                hexChars[i] = hexChar;
+              }
+              int unicodeValue = Integer.parseInt(new String(hexChars), 16);
+              result.append((char) unicodeValue);
+              break;
+            default:
+              throw new IllegalArgumentException("Invalid escape character: \\" + escapeChar);
+          }
+          position++;
+        } else {
+          result.append(currentChar());
+          position++;
+        }
+      }
+      position++; // Skip closing quote
+      return result.toString();
+    }
+
+    private Object readValue() {
+      skipWhitespace();
+      char c = currentChar();
+
+      if (c == '"') {
+        return readString();
+      } else if (Character.isDigit(c)) {
+        return readScopedNumber();
+      } else if (c == '{') {
+        return readObject(); // JSON Objects
+      } else if (c == '[') {
+        return readArray(); // JSON Arrays
+      } else if (json.startsWith("true", position)) {
+        position += 4;
+        return true;
+      } else if (json.startsWith("false", position)) {
+        position += 5;
+        return false;
+      } else if (json.startsWith("null", position)) {
+        position += 4;
+        return null; // JSON null
+      } else {
+        throw new IllegalArgumentException("Unexpected character: " + c);
+      }
+    }
+
+    private Number readScopedNumber() {
+      int start = position;
+
+      // Consume digits and the optional decimal point
+      while (position < json.length()
+          && (Character.isDigit(json.charAt(position)) || json.charAt(position) == '.')) {
+        position++;
+      }
+
+      String number = json.substring(start, position);
+
+      if (number.contains(".")) {
+        double value = Double.parseDouble(number);
+        if (value < 0.0 || value > 1.0) {
+          throw new IllegalArgumentException(
+              "Value out of bounds for Bedrock Floating Point Attribute: " + number);
+        }
+        return value;
+      } else {
+        return Integer.parseInt(number);
+      }
+    }
+
+    private Map<String, Object> readObject() {
+      Map<String, Object> map = new HashMap<>();
+      expect('{');
+      skipWhitespace();
+      while (currentChar() != '}') {
+        String key = readString();
+        expect(':');
+        Object value = readValue();
+        map.put(key, value);
+        skipWhitespace();
+        if (currentChar() == ',') {
+          position++;
+        }
+      }
+      position++; // Skip closing brace
+      return map;
+    }
+
+    private List<Object> readArray() {
+      List<Object> list = new ArrayList<>();
+      expect('[');
+      skipWhitespace();
+      while (currentChar() != ']') {
+        list.add(readValue());
+        skipWhitespace();
+        if (currentChar() == ',') {
+          position++;
+        }
+      }
+      position++;
+      return list;
+    }
+
+    public Map<String, Object> parse() {
+      return readObject();
+    }
+  }
+
+  // Resolves paths in a JSON structure
+  static class JsonPathResolver {
+
+    // Private constructor to prevent instantiation
+    private JsonPathResolver() {
+      throw new UnsupportedOperationException("Utility class");
+    }
+
+    public static Object resolvePath(LlmJson llmJson, String... paths) {
+      for (String path : paths) {
+        Object value = resolvePath(llmJson.getJsonBody(), path);
+        if (value != null) {
+          return value;
+        }
+      }
+      return null;
+    }
+
+    private static Object resolvePath(Map<String, Object> json, String path) {
+      String[] keys = path.split("/");
+      Object current = json;
+
+      for (String key : keys) {
+        if (key.isEmpty()) {
+          continue;
+        }
+
+        if (current instanceof Map) {
+          current = ((Map<?, ?>) current).get(key);
+        } else if (current instanceof List) {
+          try {
+            int index = Integer.parseInt(key);
+            current = ((List<?>) current).get(index);
+          } catch (NumberFormatException | IndexOutOfBoundsException e) {
+            return null;
+          }
+        } else {
+          return null;
+        }
+
+        if (current == null) {
+          return null;
+        }
+      }
+      return current;
+    }
+  }
+
+  /**
+   * This class is internal and is hence not for public use. Its APIs are unstable and can change at
+   * any time.
+   */
+  public static class LlmJson {
+    private final Map<String, Object> jsonBody;
+
+    public LlmJson(Map<String, Object> jsonBody) {
+      this.jsonBody = jsonBody;
+    }
+
+    public Map<String, Object> getJsonBody() {
+      return jsonBody;
+    }
+  }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/FieldMapper.java b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/FieldMapper.java
index 9e7aeacbce..9a38a753ca 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/FieldMapper.java
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/FieldMapper.java
@@ -65,8 +65,13 @@ class FieldMapper {
     for (int i = 1; i < path.size() && target != null; i++) {
       target = next(target, path.get(i));
     }
+    String value;
     if (target != null) {
-      String value = serializer.serialize(target);
+      if (AwsExperimentalAttributes.isGenAiAttribute(fieldMapping.getAttribute())) {
+        value = serializer.serialize(fieldMapping.getAttribute(), target);
+      } else {
+        value = serializer.serialize(target);
+      }
       if (!StringUtils.isEmpty(value)) {
         span.setAttribute(fieldMapping.getAttribute(), value);
       }
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/Serializer.java b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/Serializer.java
index 7ae1590152..5b7a188914 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/Serializer.java
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/Serializer.java
@@ -7,11 +7,14 @@ package io.opentelemetry.instrumentation.awssdk.v2_2.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+import software.amazon.awssdk.core.SdkBytes;
 import software.amazon.awssdk.core.SdkPojo;
 import software.amazon.awssdk.http.ContentStreamProvider;
 import software.amazon.awssdk.http.SdkHttpFullRequest;
@@ -41,6 +44,45 @@ class Serializer {
     return target.toString();
   }
 
+  @Nullable
+  String serialize(String attributeName, Object target) {
+    try {
+      // Extract JSON string from target if it is a Bedrock Runtime JSON blob
+      String jsonString;
+      if (target instanceof SdkBytes) {
+        jsonString = ((SdkBytes) target).asUtf8String();
+      } else {
+        if (target != null) {
+          return target.toString();
+        }
+        return null;
+      }
+
+      // Parse the LLM JSON string into a Map
+      BedrockJsonParser.LlmJson llmJson = BedrockJsonParser.parse(jsonString);
+
+      // Use attribute name to extract the corresponding value
+      switch (attributeName) {
+        case "gen_ai.request.max_tokens":
+          return getMaxTokens(llmJson);
+        case "gen_ai.request.temperature":
+          return getTemperature(llmJson);
+        case "gen_ai.request.top_p":
+          return getTopP(llmJson);
+        case "gen_ai.response.finish_reasons":
+          return getFinishReasons(llmJson);
+        case "gen_ai.usage.input_tokens":
+          return getInputTokens(llmJson);
+        case "gen_ai.usage.output_tokens":
+          return getOutputTokens(llmJson);
+        default:
+          return null;
+      }
+    } catch (RuntimeException e) {
+      return null;
+    }
+  }
+
   @Nullable
   private static String serialize(SdkPojo sdkPojo) {
     ProtocolMarshaller<SdkHttpFullRequest> marshaller =
@@ -65,4 +107,167 @@ class Serializer {
     String serialized = collection.stream().map(this::serialize).collect(Collectors.joining(","));
     return (StringUtils.isEmpty(serialized) ? null : "[" + serialized + "]");
   }
+
+  @Nullable
+  private static String approximateTokenCount(
+      BedrockJsonParser.LlmJson jsonBody, String... textPaths) {
+    return Arrays.stream(textPaths)
+        .map(
+            path -> {
+              Object value = BedrockJsonParser.JsonPathResolver.resolvePath(jsonBody, path);
+              if (value instanceof String) {
+                int tokenEstimate = (int) Math.ceil(((String) value).length() / 6.0);
+                return Integer.toString(tokenEstimate);
+              }
+              return null;
+            })
+        .filter(Objects::nonNull)
+        .findFirst()
+        .orElse(null);
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/inferenceConfig/max_new_tokens"
+  // Amazon Titan -> "/textGenerationConfig/maxTokenCount"
+  // Anthropic Claude -> "/max_tokens"
+  // Cohere Command -> "/max_tokens"
+  // Cohere Command R -> "/max_tokens"
+  // AI21 Jamba -> "/max_tokens"
+  // Meta Llama -> "/max_gen_len"
+  // Mistral AI -> "/max_tokens"
+  @Nullable
+  private static String getMaxTokens(BedrockJsonParser.LlmJson jsonBody) {
+    Object value =
+        BedrockJsonParser.JsonPathResolver.resolvePath(
+            jsonBody,
+            "/max_tokens",
+            "/max_gen_len",
+            "/textGenerationConfig/maxTokenCount",
+            "inferenceConfig/max_new_tokens");
+    return value != null ? String.valueOf(value) : null;
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/inferenceConfig/temperature"
+  // Amazon Titan -> "/textGenerationConfig/temperature"
+  // Anthropic Claude -> "/temperature"
+  // Cohere Command -> "/temperature"
+  // Cohere Command R -> "/temperature"
+  // AI21 Jamba -> "/temperature"
+  // Meta Llama -> "/temperature"
+  // Mistral AI -> "/temperature"
+  @Nullable
+  private static String getTemperature(BedrockJsonParser.LlmJson jsonBody) {
+    Object value =
+        BedrockJsonParser.JsonPathResolver.resolvePath(
+            jsonBody,
+            "/temperature",
+            "/textGenerationConfig/temperature",
+            "/inferenceConfig/temperature");
+    return value != null ? String.valueOf(value) : null;
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/inferenceConfig/top_p"
+  // Amazon Titan -> "/textGenerationConfig/topP"
+  // Anthropic Claude -> "/top_p"
+  // Cohere Command -> "/p"
+  // Cohere Command R -> "/p"
+  // AI21 Jamba -> "/top_p"
+  // Meta Llama -> "/top_p"
+  // Mistral AI -> "/top_p"
+  @Nullable
+  private static String getTopP(BedrockJsonParser.LlmJson jsonBody) {
+    Object value =
+        BedrockJsonParser.JsonPathResolver.resolvePath(
+            jsonBody, "/top_p", "/p", "/textGenerationConfig/topP", "/inferenceConfig/top_p");
+    return value != null ? String.valueOf(value) : null;
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/stopReason"
+  // Amazon Titan -> "/results/0/completionReason"
+  // Anthropic Claude -> "/stop_reason"
+  // Cohere Command -> "/generations/0/finish_reason"
+  // Cohere Command R -> "/finish_reason"
+  // AI21 Jamba -> "/choices/0/finish_reason"
+  // Meta Llama -> "/stop_reason"
+  // Mistral AI -> "/outputs/0/stop_reason"
+  @Nullable
+  private static String getFinishReasons(BedrockJsonParser.LlmJson jsonBody) {
+    Object value =
+        BedrockJsonParser.JsonPathResolver.resolvePath(
+            jsonBody,
+            "/stopReason",
+            "/finish_reason",
+            "/stop_reason",
+            "/results/0/completionReason",
+            "/generations/0/finish_reason",
+            "/choices/0/finish_reason",
+            "/outputs/0/stop_reason");
+
+    return value != null ? "[" + value + "]" : null;
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/usage/inputTokens"
+  // Amazon Titan -> "/inputTextTokenCount"
+  // Anthropic Claude -> "/usage/input_tokens"
+  // Cohere Command -> "/prompt"
+  // Cohere Command R -> "/message"
+  // AI21 Jamba -> "/usage/prompt_tokens"
+  // Meta Llama -> "/prompt_token_count"
+  // Mistral AI -> "/prompt"
+  @Nullable
+  private static String getInputTokens(BedrockJsonParser.LlmJson jsonBody) {
+    // Try direct tokens counts first
+    Object directCount =
+        BedrockJsonParser.JsonPathResolver.resolvePath(
+            jsonBody,
+            "/inputTextTokenCount",
+            "/prompt_token_count",
+            "/usage/input_tokens",
+            "/usage/prompt_tokens",
+            "/usage/inputTokens");
+
+    if (directCount != null) {
+      return String.valueOf(directCount);
+    }
+
+    // Fall back to token approximation
+    Object approxTokenCount = approximateTokenCount(jsonBody, "/prompt", "/message");
+
+    return approxTokenCount != null ? String.valueOf(approxTokenCount) : null;
+  }
+
+  // Model -> Path Mapping:
+  // Amazon Nova -> "/usage/outputTokens"
+  // Amazon Titan -> "/results/0/tokenCount"
+  // Anthropic Claude -> "/usage/output_tokens"
+  // Cohere Command -> "/generations/0/text"
+  // Cohere Command R -> "/text"
+  // AI21 Jamba -> "/usage/completion_tokens"
+  // Meta Llama -> "/generation_token_count"
+  // Mistral AI -> "/outputs/0/text"
+  @Nullable
+  private static String getOutputTokens(BedrockJsonParser.LlmJson jsonBody) {
+    // Try direct token counts first
+    Object directCount =
+        BedrockJsonParser.JsonPathResolver.resolvePath(
+            jsonBody,
+            "/generation_token_count",
+            "/results/0/tokenCount",
+            "/usage/output_tokens",
+            "/usage/completion_tokens",
+            "/usage/outputTokens");
+
+    if (directCount != null) {
+      return String.valueOf(directCount);
+    }
+
+    // Fall back to token approximation
+    Object approxTokenCount = approximateTokenCount(jsonBody, "/text", "/outputs/0/text");
+
+    return approxTokenCount != null ? String.valueOf(approxTokenCount) : null;
+  }
 }
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/TracingExecutionInterceptor.java b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/TracingExecutionInterceptor.java
index 94243d0b11..06d8a9141b 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/TracingExecutionInterceptor.java
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/internal/TracingExecutionInterceptor.java
@@ -5,6 +5,10 @@
 
 package io.opentelemetry.instrumentation.awssdk.v2_2.internal;
 
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_AUTH_ACCESS_KEY;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.AWS_AUTH_REGION;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsExperimentalAttributes.GEN_AI_SYSTEM;
+import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.BEDROCKRUNTIME;
 import static io.opentelemetry.instrumentation.awssdk.v2_2.internal.AwsSdkRequestType.DYNAMODB;
 
 import io.opentelemetry.api.common.AttributeKey;
@@ -28,6 +32,7 @@ import java.time.Instant;
 import java.util.Optional;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+import software.amazon.awssdk.auth.credentials.AwsCredentials;
 import software.amazon.awssdk.auth.signer.AwsSignerExecutionAttribute;
 import software.amazon.awssdk.awscore.AwsResponse;
 import software.amazon.awssdk.core.ClientType;
@@ -40,6 +45,7 @@ import software.amazon.awssdk.core.interceptor.ExecutionInterceptor;
 import software.amazon.awssdk.core.interceptor.SdkExecutionAttribute;
 import software.amazon.awssdk.http.SdkHttpRequest;
 import software.amazon.awssdk.http.SdkHttpResponse;
+import software.amazon.awssdk.regions.Region;
 
 /**
  * AWS request execution interceptor.
@@ -48,6 +54,7 @@ import software.amazon.awssdk.http.SdkHttpResponse;
  * at any time.
  */
 public final class TracingExecutionInterceptor implements ExecutionInterceptor {
+  private static final String GEN_AI_SYSTEM_BEDROCK = "aws.bedrock";
 
   // copied from DbIncubatingAttributes
   private static final AttributeKey<String> DB_OPERATION = AttributeKey.stringKey("db.operation");
@@ -261,6 +268,26 @@ public final class TracingExecutionInterceptor implements ExecutionInterceptor {
     SdkHttpRequest httpRequest = context.httpRequest();
     executionAttributes.putAttribute(SDK_HTTP_REQUEST_ATTRIBUTE, httpRequest);
 
+    if (captureExperimentalSpanAttributes) {
+      AwsCredentials credentials =
+          executionAttributes.getAttribute(AwsSignerExecutionAttribute.AWS_CREDENTIALS);
+      Region signingRegion =
+          executionAttributes.getAttribute(AwsSignerExecutionAttribute.SIGNING_REGION);
+      Span span = Span.fromContext(otelContext);
+
+      if (credentials != null) {
+        String accessKeyId = credentials.accessKeyId();
+        if (accessKeyId != null) {
+          span.setAttribute(AWS_AUTH_ACCESS_KEY, accessKeyId);
+        }
+      }
+
+      if (signingRegion != null) {
+        String region = signingRegion.toString();
+        span.setAttribute(AWS_AUTH_REGION, region);
+      }
+    }
+
     // We ought to pass the parent of otelContext here, but we didn't store it, and it shouldn't
     // make a difference (unless we start supporting the http.resend_count attribute in this
     // instrumentation, which, logically, we can't on this level of abstraction)
@@ -342,6 +369,10 @@ public final class TracingExecutionInterceptor implements ExecutionInterceptor {
         }
       }
     }
+
+    if (awsSdkRequest.type() == BEDROCKRUNTIME) {
+      span.setAttribute(GEN_AI_SYSTEM, GEN_AI_SYSTEM_BEDROCK);
+    }
   }
 
   @Override
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/library/src/test/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/internal/BedrockJsonParserTest.groovy b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/test/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/internal/BedrockJsonParserTest.groovy
new file mode 100644
index 0000000000..9dff7aa804
--- /dev/null
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/library/src/test/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/internal/BedrockJsonParserTest.groovy
@@ -0,0 +1,107 @@
+/*
+ * Copyright The OpenTelemetry Authors
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package io.opentelemetry.instrumentation.awssdk.v2_2.internal
+
+import spock.lang.Specification
+
+class BedrockJsonParserTest extends Specification {
+    def "should parse simple JSON object"() {
+        given:
+        String json = '{"key":"value"}'
+
+        when:
+        def parsedJson = BedrockJsonParser.parse(json)
+
+        then:
+        parsedJson.getJsonBody() == [key: "value"]
+    }
+
+    def "should parse nested JSON object"() {
+        given:
+        String json = '{"parent":{"child":"value"}}'
+
+        when:
+        def parsedJson = BedrockJsonParser.parse(json)
+
+        then:
+        def parent = parsedJson.getJsonBody().get("parent")
+        parent instanceof Map
+        parent["child"] == "value"
+    }
+
+    def "should parse JSON array"() {
+        given:
+        String json = '{"array":[1, "two", 1.0]}'
+
+        when:
+        def parsedJson = BedrockJsonParser.parse(json)
+
+        then:
+        def array = parsedJson.getJsonBody().get("array")
+        array instanceof List
+        array == [1, "two", 1.0]
+    }
+
+    def "should parse escape sequences"() {
+        given:
+        String json = '{"escaped":"Line1\\nLine2\\tTabbed\\\"Quoted\\\"\\bBackspace\\fFormfeed\\rCarriageReturn\\\\Backslash\\/Slash\\u0041"}'
+
+        when:
+        def parsedJson = BedrockJsonParser.parse(json)
+
+        then:
+        parsedJson.getJsonBody().get("escaped") ==
+                "Line1\nLine2\tTabbed\"Quoted\"\bBackspace\fFormfeed\rCarriageReturn\\Backslash/SlashA"
+    }
+
+    def "should throw exception for malformed JSON"() {
+        given:
+        String malformedJson = '{"key":value}'
+
+        when:
+        BedrockJsonParser.parse(malformedJson)
+
+        then:
+        def ex = thrown(IllegalArgumentException)
+        ex.message.contains("Unexpected character")
+    }
+
+    def "should resolve path in JSON object"() {
+        given:
+        String json = '{"parent":{"child":{"key":"value"}}}'
+
+        when:
+        def parsedJson = BedrockJsonParser.parse(json)
+        def resolvedValue = BedrockJsonParser.JsonPathResolver.resolvePath(parsedJson, "/parent/child/key")
+
+        then:
+        resolvedValue == "value"
+    }
+
+    def "should resolve path in JSON array"() {
+        given:
+        String json = '{"array":[{"key":"value1"}, {"key":"value2"}]}'
+
+        when:
+        def parsedJson = BedrockJsonParser.parse(json)
+        def resolvedValue = BedrockJsonParser.JsonPathResolver.resolvePath(parsedJson, "/array/1/key")
+
+        then:
+        resolvedValue == "value2"
+    }
+
+    def "should return null for invalid path resolution"() {
+        given:
+        String json = '{"parent":{"child":{"key":"value"}}}'
+
+        when:
+        def parsedJson = BedrockJsonParser.parse(json)
+        def resolvedValue = BedrockJsonParser.JsonPathResolver.resolvePath(parsedJson, "/invalid/path")
+
+        then:
+        resolvedValue == null
+    }
+}
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/testing/build.gradle.kts b/instrumentation/aws-sdk/aws-sdk-2.2/testing/build.gradle.kts
index 08b000a05c..de0fe82638 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/testing/build.gradle.kts
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/testing/build.gradle.kts
@@ -20,6 +20,9 @@ dependencies {
   compileOnly("software.amazon.awssdk:sqs:2.2.0")
   compileOnly("software.amazon.awssdk:sns:2.2.0")
   compileOnly("software.amazon.awssdk:ses:2.2.0")
+  compileOnly("software.amazon.awssdk:sfn:2.2.0")
+  compileOnly("software.amazon.awssdk:lambda:2.2.0")
+  compileOnly("software.amazon.awssdk:secretsmanager:2.2.0")
 
   // needed for SQS - using emq directly as localstack references emq v0.15.7 ie WITHOUT AWS trace header propagation
   implementation("org.elasticmq:elasticmq-rest-sqs_2.13")
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientCoreTest.groovy b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientCoreTest.groovy
index 9aaacb3abe..198990a509 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientCoreTest.groovy
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientCoreTest.groovy
@@ -146,6 +146,8 @@ abstract class AbstractAws2ClientCoreTest extends InstrumentationSpecification {
             "$RpcIncubatingAttributes.RPC_SYSTEM" "aws-api"
             "$RpcIncubatingAttributes.RPC_SERVICE" "DynamoDb"
             "$RpcIncubatingAttributes.RPC_METHOD" "CreateTable"
+            "aws.auth.account.access_key" "my-access-key"
+            "aws.auth.region" "ap-northeast-1"
             "aws.agent" "java-aws-sdk"
             "$AwsIncubatingAttributes.AWS_REQUEST_ID" "$requestId"
             "aws.table.name" "sometable"
@@ -179,6 +181,8 @@ abstract class AbstractAws2ClientCoreTest extends InstrumentationSpecification {
             "$RpcIncubatingAttributes.RPC_SYSTEM" "aws-api"
             "$RpcIncubatingAttributes.RPC_SERVICE" "DynamoDb"
             "$RpcIncubatingAttributes.RPC_METHOD" "Query"
+            "aws.auth.account.access_key" "my-access-key"
+            "aws.auth.region" "ap-northeast-1"
             "aws.agent" "java-aws-sdk"
             "$AwsIncubatingAttributes.AWS_REQUEST_ID" "$requestId"
             "aws.table.name" "sometable"
@@ -211,6 +215,8 @@ abstract class AbstractAws2ClientCoreTest extends InstrumentationSpecification {
             "$RpcIncubatingAttributes.RPC_SYSTEM" "aws-api"
             "$RpcIncubatingAttributes.RPC_SERVICE" "$service"
             "$RpcIncubatingAttributes.RPC_METHOD" "${operation}"
+            "aws.auth.account.access_key" "my-access-key"
+            "aws.auth.region" "ap-northeast-1"
             "aws.agent" "java-aws-sdk"
             "$AwsIncubatingAttributes.AWS_REQUEST_ID" "$requestId"
             "aws.table.name" "sometable"
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientTest.groovy b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientTest.groovy
index c571c0aa9c..6836115c32 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientTest.groovy
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/groovy/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientTest.groovy
@@ -26,6 +26,7 @@ import software.amazon.awssdk.regions.Region
 import software.amazon.awssdk.services.ec2.Ec2AsyncClient
 import software.amazon.awssdk.services.ec2.Ec2Client
 import software.amazon.awssdk.services.kinesis.KinesisClient
+import software.amazon.awssdk.services.kinesis.model.DescribeStreamRequest
 import software.amazon.awssdk.services.kinesis.model.DeleteStreamRequest
 import software.amazon.awssdk.services.rds.RdsAsyncClient
 import software.amazon.awssdk.services.rds.RdsClient
@@ -37,10 +38,19 @@ import software.amazon.awssdk.services.s3.model.GetObjectRequest
 import software.amazon.awssdk.services.sns.SnsAsyncClient
 import software.amazon.awssdk.services.sns.SnsClient
 import software.amazon.awssdk.services.sns.model.PublishRequest
+import software.amazon.awssdk.services.sns.model.SubscribeRequest
 import software.amazon.awssdk.services.sqs.SqsAsyncClient
 import software.amazon.awssdk.services.sqs.SqsClient
 import software.amazon.awssdk.services.sqs.model.CreateQueueRequest
 import software.amazon.awssdk.services.sqs.model.SendMessageRequest
+import software.amazon.awssdk.services.sfn.SfnClient
+import software.amazon.awssdk.services.sfn.model.DescribeStateMachineRequest
+import software.amazon.awssdk.services.sfn.model.DescribeActivityRequest
+import software.amazon.awssdk.services.lambda.LambdaClient
+import software.amazon.awssdk.services.lambda.model.GetFunctionRequest
+import software.amazon.awssdk.services.lambda.model.GetEventSourceMappingRequest
+import software.amazon.awssdk.services.secretsmanager.SecretsManagerClient
+import software.amazon.awssdk.services.secretsmanager.model.GetSecretValueRequest
 import spock.lang.Unroll
 
 import java.nio.charset.StandardCharsets
@@ -134,6 +144,8 @@ abstract class AbstractAws2ClientTest extends AbstractAws2ClientCoreTest {
             "$RpcIncubatingAttributes.RPC_SYSTEM" "aws-api"
             "$RpcIncubatingAttributes.RPC_SERVICE" "$service"
             "$RpcIncubatingAttributes.RPC_METHOD" "${operation}"
+            "aws.auth.account.access_key" "my-access-key"
+            "aws.auth.region" "ap-northeast-1"
             "aws.agent" "java-aws-sdk"
             "$AwsIncubatingAttributes.AWS_REQUEST_ID" "$requestId"
             if (service == "S3") {
@@ -148,8 +160,32 @@ abstract class AbstractAws2ClientTest extends AbstractAws2ClientCoreTest {
               "$MessagingIncubatingAttributes.MESSAGING_SYSTEM" MessagingIncubatingAttributes.MessagingSystemIncubatingValues.AWS_SQS
             } else if (service == "Kinesis") {
               "aws.stream.name" "somestream"
-            } else if (service == "Sns") {
-              "$MessagingIncubatingAttributes.MESSAGING_DESTINATION_NAME" "somearn"
+            } else if (service == "Sns" && operation == "Publish") {
+              "$MessagingIncubatingAttributes.MESSAGING_DESTINATION_NAME" "sometargetarn"
+            } else if (service == "Sns" && operation == "Subscribe") {
+              "$MessagingIncubatingAttributes.MESSAGING_DESTINATION_NAME" "sometopicarn"
+              "aws.sns.topic.arn" "sometopicarn"
+            } else if (service == "Bedrock" && operation == "GetGuardrail") {
+              "aws.bedrock.guardrail.id" "guardrailId"
+            } else if (service == "BedrockAgent" && operation == "GetAgent") {
+              "aws.bedrock.agent.id" "agentId"
+            } else if (service == "BedrockAgent" && operation == "GetKnowledgeBase") {
+              "aws.bedrock.knowledge_base.id" "knowledgeBaseId"
+            } else if (service == "BedrockAgent" && operation == "GetDataSource") {
+              "aws.bedrock.data_source.id" "datasourceId"
+            } else if (service == "BedrockRuntime" && operation == "InvokeModel") {
+              "gen_ai.request.model" "meta.llama2-13b-chat-v1"
+              "gen_ai.system" "aws.bedrock"
+            } else if (service == "Sfn" && operation == "DescribeStateMachine") {
+              "aws.stepfunctions.state_machine.arn" "stateMachineArn"
+            } else if (service == "Sfn" && operation == "DescribeActivity") {
+              "aws.stepfunctions.activity.arn" "activityArn"
+            } else if (service == "Lambda" && operation == "GetFunction") {
+              "aws.lambda.function.name" "functionName"
+            } else if (service == "Lambda" && operation == "GetEventSourceMapping") {
+              "aws.lambda.resource_mapping.id" "sourceEventId"
+            } else if (service == "SecretsManager") {
+              "aws.secretsmanager.secret.arn" "someSecretArn"
             }
           }
         }
@@ -164,7 +200,7 @@ abstract class AbstractAws2ClientTest extends AbstractAws2ClientCoreTest {
     "S3"      | "CreateBucket"      | "PUT"  | "UNKNOWN"                              | s3ClientBuilder()       | { c -> c.createBucket(CreateBucketRequest.builder().bucket("somebucket").build()) }              | ""
     "S3"      | "GetObject"         | "GET"  | "UNKNOWN"                              | s3ClientBuilder()       | { c -> c.getObject(GetObjectRequest.builder().bucket("somebucket").key("somekey").build()) }     | ""
     "Kinesis" | "DeleteStream"      | "POST" | "UNKNOWN"                              | KinesisClient.builder() | { c -> c.deleteStream(DeleteStreamRequest.builder().streamName("somestream").build()) }          | ""
-    "Sns"     | "Publish"           | "POST" | "d74b8436-ae13-5ab4-a9ff-ce54dfea72a0" | SnsClient.builder()     | { c -> c.publish(PublishRequest.builder().message("somemessage").topicArn("somearn").build()) }  | """
+    "Sns"     | "Publish"           | "POST" | "d74b8436-ae13-5ab4-a9ff-ce54dfea72a0" | SnsClient.builder()     | { c -> c.publish(PublishRequest.builder().message("somemessage").targetArn("sometargetarn").build()) }  | """
           <PublishResponse xmlns="https://sns.amazonaws.com/doc/2010-03-31/">
               <PublishResult>
                   <MessageId>567910cd-659e-55d4-8ccb-5aaf14679dc0</MessageId>
@@ -174,15 +210,15 @@ abstract class AbstractAws2ClientTest extends AbstractAws2ClientCoreTest {
               </ResponseMetadata>
           </PublishResponse>
       """
-    "Sns"     | "Publish"           | "POST" | "d74b8436-ae13-5ab4-a9ff-ce54dfea72a0" | SnsClient.builder()     | { c -> c.publish(PublishRequest.builder().message("somemessage").targetArn("somearn").build()) } | """
-          <PublishResponse xmlns="https://sns.amazonaws.com/doc/2010-03-31/">
-              <PublishResult>
-                  <MessageId>567910cd-659e-55d4-8ccb-5aaf14679dc0</MessageId>
-              </PublishResult>
+    "Sns" | "Subscribe" | "POST" | "1234-5678-9101-1121" | SnsClient.builder() | { c -> c.subscribe(SubscribeRequest.builder().topicArn("sometopicarn").protocol("email").endpoint("test@example.com").build())} | """
+          <SubscribeResponse xmlns="https://sns.amazonaws.com/doc/2010-03-31/">
+              <SubscribeResult>
+                  <SubscriptionArn>arn:aws:sns:us-west-2:123456789012:MyTopic:abc123</SubscriptionArn>
+              </SubscribeResult>
               <ResponseMetadata>
-                  <RequestId>d74b8436-ae13-5ab4-a9ff-ce54dfea72a0</RequestId>
+                  <RequestId>1234-5678-9101-1121</RequestId>
               </ResponseMetadata>
-          </PublishResponse>
+          </SubscribeResponse>
       """
     "Sqs"     | "CreateQueue"       | "POST" | "7a62c49f-347e-4fc4-9331-6e8e7a96aa73" | SqsClient.builder()     | { c -> c.createQueue(CreateQueueRequest.builder().queueName("somequeue").build()) }              | {
       if (!Boolean.getBoolean("testLatestDeps")) {
@@ -244,170 +280,193 @@ abstract class AbstractAws2ClientTest extends AbstractAws2ClientCoreTest {
           <ResponseMetadata><RequestId>0ac9cda2-bbf4-11d3-f92b-31fa5e8dbc99</RequestId></ResponseMetadata>
         </DeleteOptionGroupResponse>
         """
-  }
-
-  def "send #operation async request with builder #builder.class.getName() mocked response"() {
-    assumeSupportedConfig(service, operation)
-    setup:
-    configureSdkClient(builder)
-    def client = builder
-        .endpointOverride(clientUri)
-        .region(Region.AP_NORTHEAST_1)
-        .credentialsProvider(CREDENTIALS_PROVIDER)
-        .build()
-
-    if (body instanceof Closure) {
-      server.enqueue(body.call())
-    } else {
-      server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, body))
-    }
-
-    def response = call.call(client)
-    if (response instanceof Future) {
-      response = response.get()
-    }
-
-    expect:
-    response != null
-
-    assertTraces(1) {
-      trace(0, 1) {
-        span(0) {
-          name operation != "SendMessage" ? "$service.$operation" : "somequeue publish"
-          kind operation != "SendMessage" ? CLIENT : PRODUCER
-          hasNoParent()
-          attributes {
-            if (service == "S3") {
-              // Starting with AWS SDK V2 2.18.0, the s3 sdk will prefix the hostname with the bucket name in case
-              // the bucket name is a valid DNS label, even in the case that we are using an endpoint override.
-              // Previously the sdk was only doing that if endpoint had "s3" as label in the FQDN.
-              // Our test assert both cases so that we don't need to know what version is being tested.
-              "$ServerAttributes.SERVER_ADDRESS" { it == "somebucket.localhost" || it == "localhost" }
-              "$UrlAttributes.URL_FULL" { it.startsWith("http://somebucket.localhost:${server.httpPort()}") || it.startsWith("http://localhost:${server.httpPort()}") }
-            } else {
-              "$ServerAttributes.SERVER_ADDRESS" "localhost"
-              "$UrlAttributes.URL_FULL" { it == "http://localhost:${server.httpPort()}" || it == "http://localhost:${server.httpPort()}/" }
-            }
-            "$ServerAttributes.SERVER_PORT" server.httpPort()
-            "$HttpAttributes.HTTP_REQUEST_METHOD" "$method"
-            "$HttpAttributes.HTTP_RESPONSE_STATUS_CODE" 200
-            "$RpcIncubatingAttributes.RPC_SYSTEM" "aws-api"
-            "$RpcIncubatingAttributes.RPC_SERVICE" "$service"
-            "$RpcIncubatingAttributes.RPC_METHOD" "${operation}"
-            "aws.agent" "java-aws-sdk"
-            "$AwsIncubatingAttributes.AWS_REQUEST_ID" "$requestId"
-            if (service == "S3") {
-              "aws.bucket.name" "somebucket"
-            } else if (service == "Sqs" && operation == "CreateQueue") {
-              "aws.queue.name" "somequeue"
-            } else if (service == "Sqs" && operation == "SendMessage") {
-              "aws.queue.url" QUEUE_URL
-              "$MessagingIncubatingAttributes.MESSAGING_DESTINATION_NAME" "somequeue"
-              "$MessagingIncubatingAttributes.MESSAGING_OPERATION" "publish"
-              "$MessagingIncubatingAttributes.MESSAGING_MESSAGE_ID" String
-              "$MessagingIncubatingAttributes.MESSAGING_SYSTEM" MessagingIncubatingAttributes.MessagingSystemIncubatingValues.AWS_SQS
-            } else if (service == "Kinesis") {
-              "aws.stream.name" "somestream"
-            } else if (service == "Sns") {
-              "$MessagingIncubatingAttributes.MESSAGING_DESTINATION_NAME" "somearn"
-            }
-          }
-        }
-      }
-    }
-    def request = server.takeRequest()
-    request.request().headers().get("X-Amzn-Trace-Id") != null
-    request.request().headers().get("traceparent") == null
-
-    if (service == "Sns" && operation == "Publish") {
-      def content = request.request().content().toStringUtf8()
-      def containsId = content.contains("${traces[0][0].traceId}-${traces[0][0].spanId}")
-      def containsTp = content.contains("=traceparent")
-      if (isSqsAttributeInjectionEnabled()) {
-        assert containsId && containsTp
-      } else {
-        assert !containsId && !containsTp
-      }
-    }
-
-    where:
-    service | operation           | method | requestId                              | builder                  | call                                                                                                                             | body
-    "S3"    | "CreateBucket"      | "PUT"  | "UNKNOWN"                              | s3AsyncClientBuilder()   | { c -> c.createBucket(CreateBucketRequest.builder().bucket("somebucket").build()) }                                              | ""
-    "S3"    | "GetObject"         | "GET"  | "UNKNOWN"                              | s3AsyncClientBuilder()   | { c -> c.getObject(GetObjectRequest.builder().bucket("somebucket").key("somekey").build(), AsyncResponseTransformer.toBytes()) } | "1234567890"
-    // Kinesis seems to expect an http2 response which is incompatible with our test server.
-    // "Kinesis"  | "DeleteStream"      | "POST" | "/"                   | "UNKNOWN"                              | KinesisAsyncClient.builder()  | { c -> c.deleteStream(DeleteStreamRequest.builder().streamName("somestream").build()) }                                          | ""
-    "Sqs"   | "CreateQueue"       | "POST" | "7a62c49f-347e-4fc4-9331-6e8e7a96aa73" | SqsAsyncClient.builder() | { c -> c.createQueue(CreateQueueRequest.builder().queueName("somequeue").build()) }                                              | {
-      if (!Boolean.getBoolean("testLatestDeps")) {
-        def content = """
-            <CreateQueueResponse>
-                <CreateQueueResult><QueueUrl>https://queue.amazonaws.com/123456789012/MyQueue</QueueUrl></CreateQueueResult>
-                <ResponseMetadata><RequestId>7a62c49f-347e-4fc4-9331-6e8e7a96aa73</RequestId></ResponseMetadata>
-            </CreateQueueResponse>
-            """
-        return HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, content)
-      }
-      def content = """
-          {
-            "QueueUrl":"https://queue.amazonaws.com/123456789012/MyQueue"
-          }
-          """
-      ResponseHeaders headers = ResponseHeaders.builder(HttpStatus.OK)
-          .contentType(MediaType.PLAIN_TEXT_UTF_8)
-          .add("x-amzn-RequestId", "7a62c49f-347e-4fc4-9331-6e8e7a96aa73")
-          .build()
-      return HttpResponse.of(headers, HttpData.of(StandardCharsets.UTF_8, content))
-    }
-    "Sqs"   | "SendMessage"       | "POST" | "27daac76-34dd-47df-bd01-1f6e873584a0" | SqsAsyncClient.builder() | { c -> c.sendMessage(SendMessageRequest.builder().queueUrl(QUEUE_URL).messageBody("").build()) }                                 | {
-      if (!Boolean.getBoolean("testLatestDeps")) {
-        def content = """
-          <SendMessageResponse>
-              <SendMessageResult>
-                  <MD5OfMessageBody>d41d8cd98f00b204e9800998ecf8427e</MD5OfMessageBody>
-                  <MD5OfMessageAttributes>3ae8f24a165a8cedc005670c81a27295</MD5OfMessageAttributes>
-                  <MessageId>5fea7756-0ea4-451a-a703-a558b933e274</MessageId>
-              </SendMessageResult>
-              <ResponseMetadata><RequestId>27daac76-34dd-47df-bd01-1f6e873584a0</RequestId></ResponseMetadata>
-          </SendMessageResponse>
-          """
-        return HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, content)
+    "Sfn" | "DescribeStateMachine" | "POST" | "UNKNOWN" | SfnClient.builder()
+      | { c -> c.describeStateMachine(DescribeStateMachineRequest.builder().stateMachineArn("stateMachineArn").build()) }
+      | ""
+    "Sfn" | "DescribeActivity" | "POST" | "UNKNOWN" | SfnClient.builder()
+      | { c -> c.describeActivity(DescribeActivityRequest.builder().activityArn("activityArn").build()) }
+      | ""
+    "Lambda" | "GetFunction" | "GET" | "UNKNOWN" | LambdaClient.builder()
+      | { c -> c.getFunction(GetFunctionRequest.builder().functionName("functionName").build()) }
+      | ""
+    "Lambda" | "GetEventSourceMapping" | "GET" |"UNKNOWN" | LambdaClient.builder()
+      | { c -> c.getEventSourceMapping(GetEventSourceMappingRequest.builder().uuid("sourceEventId").build()) }
+      | ""
+    "SecretsManager" | "GetSecretValue" | "POST" | "UNKNOWN" | SecretsManagerClient.builder()
+      | { c -> c.getSecretValue(GetSecretValueRequest.builder().secretId("someSecret1").build()) }
+      | """
+      {
+        "ARN":"someSecretArn",
+        "CreatedDate":1.523477145713E9,
+        "Name":"MyTestDatabaseSecret",
+        "SecretString":"{\\n  \\"username\\":\\"david\\",\\n  \\"password\\":\\"EXAMPLE-PASSWORD\\"\\n}\\n",
+        "VersionId":"EXAMPLE1-90ab-cdef-fedc-ba987SECRET1"
       }
-      def content = """
-          {
-            "MD5OfMessageBody":"d41d8cd98f00b204e9800998ecf8427e",
-            "MD5OfMessageAttributes":"3ae8f24a165a8cedc005670c81a27295",
-            "MessageId":"5fea7756-0ea4-451a-a703-a558b933e274"
-          }
-          """
-      ResponseHeaders headers = ResponseHeaders.builder(HttpStatus.OK)
-          .contentType(MediaType.PLAIN_TEXT_UTF_8)
-          .add("x-amzn-RequestId", "27daac76-34dd-47df-bd01-1f6e873584a0")
-          .build()
-      return HttpResponse.of(headers, HttpData.of(StandardCharsets.UTF_8, content))
-    }
-    "Ec2"   | "AllocateAddress"   | "POST" | "59dbff89-35bd-4eac-99ed-be587EXAMPLE" | Ec2AsyncClient.builder() | { c -> c.allocateAddress() }                                                                                                     | """
-        <AllocateAddressResponse xmlns="http://ec2.amazonaws.com/doc/2016-11-15/">
-           <requestId>59dbff89-35bd-4eac-99ed-be587EXAMPLE</requestId> 
-           <publicIp>192.0.2.1</publicIp>
-           <domain>standard</domain>
-        </AllocateAddressResponse>
-        """
-    "Rds"   | "DeleteOptionGroup" | "POST" | "0ac9cda2-bbf4-11d3-f92b-31fa5e8dbc99" | RdsAsyncClient.builder() | { c -> c.deleteOptionGroup(DeleteOptionGroupRequest.builder().build()) }                                                         | """
-        <DeleteOptionGroupResponse xmlns="http://rds.amazonaws.com/doc/2014-09-01/">
-          <ResponseMetadata><RequestId>0ac9cda2-bbf4-11d3-f92b-31fa5e8dbc99</RequestId></ResponseMetadata>
-        </DeleteOptionGroupResponse>
-        """
-    "Sns"   | "Publish"           | "POST" | "f187a3c1-376f-11df-8963-01868b7c937a" | SnsAsyncClient.builder() | { SnsAsyncClient c -> c.publish(r -> r.message("hello").topicArn("somearn")) }                                                   | """
-      <PublishResponse xmlns="https://sns.amazonaws.com/doc/2010-03-31/">
-          <PublishResult>
-              <MessageId>94f20ce6-13c5-43a0-9a9e-ca52d816e90b</MessageId>
-          </PublishResult>
-          <ResponseMetadata>
-              <RequestId>f187a3c1-376f-11df-8963-01868b7c937a</RequestId>
-          </ResponseMetadata>
-      </PublishResponse> 
-      """
+    """
   }
 
+//  def "send #operation async request with builder #builder.class.getName() mocked response"() {
+//    assumeSupportedConfig(service, operation)
+//    setup:
+//    configureSdkClient(builder)
+//    def client = builder
+//        .endpointOverride(clientUri)
+//        .region(Region.AP_NORTHEAST_1)
+//        .credentialsProvider(CREDENTIALS_PROVIDER)
+//        .build()
+//
+//    if (body instanceof Closure) {
+//      server.enqueue(body.call())
+//    } else {
+//      server.enqueue(HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, body))
+//    }
+//
+//    def response = call.call(client)
+//    if (response instanceof Future) {
+//      response = response.get()
+//    }
+//
+//    expect:
+//    response != null
+//
+//    assertTraces(1) {
+//      trace(0, 1) {
+//        span(0) {
+//          name operation != "SendMessage" ? "$service.$operation" : "somequeue publish"
+//          kind operation != "SendMessage" ? CLIENT : PRODUCER
+//          hasNoParent()
+//          attributes {
+//            if (service == "S3") {
+//              // Starting with AWS SDK V2 2.18.0, the s3 sdk will prefix the hostname with the bucket name in case
+//              // the bucket name is a valid DNS label, even in the case that we are using an endpoint override.
+//              // Previously the sdk was only doing that if endpoint had "s3" as label in the FQDN.
+//              // Our test assert both cases so that we don't need to know what version is being tested.
+//              "$ServerAttributes.SERVER_ADDRESS" { it == "somebucket.localhost" || it == "localhost" }
+//              "$UrlAttributes.URL_FULL" { it.startsWith("http://somebucket.localhost:${server.httpPort()}") || it.startsWith("http://localhost:${server.httpPort()}") }
+//            } else {
+//              "$ServerAttributes.SERVER_ADDRESS" "localhost"
+//              "$UrlAttributes.URL_FULL" { it == "http://localhost:${server.httpPort()}" || it == "http://localhost:${server.httpPort()}/" }
+//            }
+//            "$ServerAttributes.SERVER_PORT" server.httpPort()
+//            "$HttpAttributes.HTTP_REQUEST_METHOD" "$method"
+//            "$HttpAttributes.HTTP_RESPONSE_STATUS_CODE" 200
+//            "$RpcIncubatingAttributes.RPC_SYSTEM" "aws-api"
+//            "$RpcIncubatingAttributes.RPC_SERVICE" "$service"
+//            "$RpcIncubatingAttributes.RPC_METHOD" "${operation}"
+//            "aws.agent" "java-aws-sdk"
+//            "$AwsIncubatingAttributes.AWS_REQUEST_ID" "$requestId"
+//            if (service == "S3") {
+//              "aws.bucket.name" "somebucket"
+//            } else if (service == "Sqs" && operation == "CreateQueue") {
+//              "aws.queue.name" "somequeue"
+//            } else if (service == "Sqs" && operation == "SendMessage") {
+//              "aws.queue.url" QUEUE_URL
+//              "$MessagingIncubatingAttributes.MESSAGING_DESTINATION_NAME" "somequeue"
+//              "$MessagingIncubatingAttributes.MESSAGING_OPERATION" "publish"
+//              "$MessagingIncubatingAttributes.MESSAGING_MESSAGE_ID" String
+//              "$MessagingIncubatingAttributes.MESSAGING_SYSTEM" MessagingIncubatingAttributes.MessagingSystemIncubatingValues.AWS_SQS
+//            } else if (service == "Kinesis") {
+//              "aws.stream.name" "somestream"
+//            } else if (service == "Sns") {
+//              "$MessagingIncubatingAttributes.MESSAGING_DESTINATION_NAME" "somearn"
+//            }
+//          }
+//        }
+//      }
+//    }
+//    def request = server.takeRequest()
+//    request.request().headers().get("X-Amzn-Trace-Id") != null
+//    request.request().headers().get("traceparent") == null
+//
+//    if (service == "Sns" && operation == "Publish") {
+//      def content = request.request().content().toStringUtf8()
+//      def containsId = content.contains("${traces[0][0].traceId}-${traces[0][0].spanId}")
+//      def containsTp = content.contains("=traceparent")
+//      if (isSqsAttributeInjectionEnabled()) {
+//        assert containsId && containsTp
+//      } else {
+//        assert !containsId && !containsTp
+//      }
+//    }
+//
+//    where:
+//    service | operation           | method | requestId                              | builder                  | call                                                                                                                             | body
+//    "S3"    | "CreateBucket"      | "PUT"  | "UNKNOWN"                              | s3AsyncClientBuilder()   | { c -> c.createBucket(CreateBucketRequest.builder().bucket("somebucket").build()) }                                              | ""
+//    "S3"    | "GetObject"         | "GET"  | "UNKNOWN"                              | s3AsyncClientBuilder()   | { c -> c.getObject(GetObjectRequest.builder().bucket("somebucket").key("somekey").build(), AsyncResponseTransformer.toBytes()) } | "1234567890"
+//    // Kinesis seems to expect an http2 response which is incompatible with our test server.
+//    // "Kinesis"  | "DeleteStream"      | "POST" | "/"                   | "UNKNOWN"                              | KinesisAsyncClient.builder()  | { c -> c.deleteStream(DeleteStreamRequest.builder().streamName("somestream").build()) }                                          | ""
+//    "Sqs"   | "CreateQueue"       | "POST" | "7a62c49f-347e-4fc4-9331-6e8e7a96aa73" | SqsAsyncClient.builder() | { c -> c.createQueue(CreateQueueRequest.builder().queueName("somequeue").build()) }                                              | {
+//      if (!Boolean.getBoolean("testLatestDeps")) {
+//        def content = """
+//            <CreateQueueResponse>
+//                <CreateQueueResult><QueueUrl>https://queue.amazonaws.com/123456789012/MyQueue</QueueUrl></CreateQueueResult>
+//                <ResponseMetadata><RequestId>7a62c49f-347e-4fc4-9331-6e8e7a96aa73</RequestId></ResponseMetadata>
+//            </CreateQueueResponse>
+//            """
+//        return HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, content)
+//      }
+//      def content = """
+//          {
+//            "QueueUrl":"https://queue.amazonaws.com/123456789012/MyQueue"
+//          }
+//          """
+//      ResponseHeaders headers = ResponseHeaders.builder(HttpStatus.OK)
+//          .contentType(MediaType.PLAIN_TEXT_UTF_8)
+//          .add("x-amzn-RequestId", "7a62c49f-347e-4fc4-9331-6e8e7a96aa73")
+//          .build()
+//      return HttpResponse.of(headers, HttpData.of(StandardCharsets.UTF_8, content))
+//    }
+//    "Sqs"   | "SendMessage"       | "POST" | "27daac76-34dd-47df-bd01-1f6e873584a0" | SqsAsyncClient.builder() | { c -> c.sendMessage(SendMessageRequest.builder().queueUrl(QUEUE_URL).messageBody("").build()) }                                 | {
+//      if (!Boolean.getBoolean("testLatestDeps")) {
+//        def content = """
+//          <SendMessageResponse>
+//              <SendMessageResult>
+//                  <MD5OfMessageBody>d41d8cd98f00b204e9800998ecf8427e</MD5OfMessageBody>
+//                  <MD5OfMessageAttributes>3ae8f24a165a8cedc005670c81a27295</MD5OfMessageAttributes>
+//                  <MessageId>5fea7756-0ea4-451a-a703-a558b933e274</MessageId>
+//              </SendMessageResult>
+//              <ResponseMetadata><RequestId>27daac76-34dd-47df-bd01-1f6e873584a0</RequestId></ResponseMetadata>
+//          </SendMessageResponse>
+//          """
+//        return HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, content)
+//      }
+//      def content = """
+//          {
+//            "MD5OfMessageBody":"d41d8cd98f00b204e9800998ecf8427e",
+//            "MD5OfMessageAttributes":"3ae8f24a165a8cedc005670c81a27295",
+//            "MessageId":"5fea7756-0ea4-451a-a703-a558b933e274"
+//          }
+//          """
+//      ResponseHeaders headers = ResponseHeaders.builder(HttpStatus.OK)
+//          .contentType(MediaType.PLAIN_TEXT_UTF_8)
+//          .add("x-amzn-RequestId", "27daac76-34dd-47df-bd01-1f6e873584a0")
+//          .build()
+//      return HttpResponse.of(headers, HttpData.of(StandardCharsets.UTF_8, content))
+//    }
+//    "Ec2"   | "AllocateAddress"   | "POST" | "59dbff89-35bd-4eac-99ed-be587EXAMPLE" | Ec2AsyncClient.builder() | { c -> c.allocateAddress() }                                                                                                     | """
+//        <AllocateAddressResponse xmlns="http://ec2.amazonaws.com/doc/2016-11-15/">
+//           <requestId>59dbff89-35bd-4eac-99ed-be587EXAMPLE</requestId>
+//           <publicIp>192.0.2.1</publicIp>
+//           <domain>standard</domain>
+//        </AllocateAddressResponse>
+//        """
+//    "Rds"   | "DeleteOptionGroup" | "POST" | "0ac9cda2-bbf4-11d3-f92b-31fa5e8dbc99" | RdsAsyncClient.builder() | { c -> c.deleteOptionGroup(DeleteOptionGroupRequest.builder().build()) }                                                         | """
+//        <DeleteOptionGroupResponse xmlns="http://rds.amazonaws.com/doc/2014-09-01/">
+//          <ResponseMetadata><RequestId>0ac9cda2-bbf4-11d3-f92b-31fa5e8dbc99</RequestId></ResponseMetadata>
+//        </DeleteOptionGroupResponse>
+//        """
+//    "Sns"   | "Publish"           | "POST" | "f187a3c1-376f-11df-8963-01868b7c937a" | SnsAsyncClient.builder() | { SnsAsyncClient c -> c.publish(r -> r.message("hello").topicArn("somearn")) }                                                   | """
+//      <PublishResponse xmlns="https://sns.amazonaws.com/doc/2010-03-31/">
+//          <PublishResult>
+//              <MessageId>94f20ce6-13c5-43a0-9a9e-ca52d816e90b</MessageId>
+//          </PublishResult>
+//          <ResponseMetadata>
+//              <RequestId>f187a3c1-376f-11df-8963-01868b7c937a</RequestId>
+//          </ResponseMetadata>
+//      </PublishResponse>
+//      """
+//  }
+
   // TODO: Without AOP instrumentation of the HTTP client, we cannot model retries as
   // spans because of https://github.com/aws/aws-sdk-java-v2/issues/1741. We should at least tweak
   // the instrumentation to add Events for retries instead.
@@ -457,6 +516,8 @@ abstract class AbstractAws2ClientTest extends AbstractAws2ClientCoreTest {
             "$RpcIncubatingAttributes.RPC_SYSTEM" "aws-api"
             "$RpcIncubatingAttributes.RPC_SERVICE" "S3"
             "$RpcIncubatingAttributes.RPC_METHOD" "GetObject"
+            "aws.auth.account.access_key" "my-access-key"
+            "aws.auth.region" "ap-northeast-1"
             "aws.agent" "java-aws-sdk"
             "aws.bucket.name" "somebucket"
           }
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientRecordHttpErrorTest.java b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientRecordHttpErrorTest.java
index 73d2a0ba82..f46361a078 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientRecordHttpErrorTest.java
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2ClientRecordHttpErrorTest.java
@@ -172,6 +172,8 @@ public abstract class AbstractAws2ClientRecordHttpErrorTest {
                       span.hasKind(SpanKind.CLIENT);
                       span.hasNoParent();
                       span.hasAttributesSatisfyingExactly(
+                          equalTo(stringKey("aws.auth.account.access_key"), "my-access-key"),
+                          equalTo(stringKey("aws.auth.region"), "ap-northeast-1"),
                           equalTo(SERVER_ADDRESS, "127.0.0.1"),
                           equalTo(SERVER_PORT, server.httpPort()),
                           equalTo(HTTP_REQUEST_METHOD, method),
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2SqsBaseTest.java b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2SqsBaseTest.java
index 902bfdc0d4..4db85ba568 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2SqsBaseTest.java
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2SqsBaseTest.java
@@ -214,6 +214,8 @@ public abstract class AbstractAws2SqsBaseTest {
             equalTo(RPC_SYSTEM, "aws-api"),
             equalTo(RPC_SERVICE, "Sqs"),
             equalTo(RPC_METHOD, "CreateQueue"),
+            equalTo(stringKey("aws.auth.account.access_key"), "my-access-key"),
+            equalTo(stringKey("aws.auth.region"), "ap-northeast-1"),
             equalTo(HTTP_REQUEST_METHOD, "POST"),
             equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
             satisfies(URL_FULL, v -> v.startsWith("http://localhost:" + sqsPort)),
@@ -232,6 +234,8 @@ public abstract class AbstractAws2SqsBaseTest {
             equalTo(RPC_SYSTEM, "aws-api"),
             equalTo(RPC_SERVICE, "Sqs"),
             equalTo(RPC_METHOD, "ReceiveMessage"),
+            equalTo(stringKey("aws.auth.account.access_key"), "my-access-key"),
+            equalTo(stringKey("aws.auth.region"), "ap-northeast-1"),
             equalTo(HTTP_REQUEST_METHOD, "POST"),
             equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
             satisfies(URL_FULL, v -> v.startsWith("http://localhost:" + sqsPort)),
@@ -257,6 +261,8 @@ public abstract class AbstractAws2SqsBaseTest {
             equalTo(RPC_SYSTEM, "aws-api"),
             equalTo(RPC_SERVICE, "Sqs"),
             equalTo(RPC_METHOD, rcpMethod),
+            equalTo(stringKey("aws.auth.account.access_key"), "my-access-key"),
+            equalTo(stringKey("aws.auth.region"), "ap-northeast-1"),
             equalTo(HTTP_REQUEST_METHOD, "POST"),
             equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
             satisfies(URL_FULL, v -> v.startsWith("http://localhost:" + sqsPort)),
diff --git a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2SqsTracingTest.java b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2SqsTracingTest.java
index 6fa897d462..f7ac28762c 100644
--- a/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2SqsTracingTest.java
+++ b/instrumentation/aws-sdk/aws-sdk-2.2/testing/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/AbstractAws2SqsTracingTest.java
@@ -80,6 +80,9 @@ public abstract class AbstractAws2SqsTracingTest extends AbstractAws2SqsBaseTest
                                   equalTo(RPC_METHOD, "SendMessage"),
                                   equalTo(HTTP_REQUEST_METHOD, "POST"),
                                   equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
+                                  equalTo(
+                                      stringKey("aws.auth.account.access_key"), "my-access-key"),
+                                  equalTo(stringKey("aws.auth.region"), "ap-northeast-1"),
                                   satisfies(
                                       URL_FULL, v -> v.startsWith("http://localhost:" + sqsPort)),
                                   equalTo(SERVER_ADDRESS, "localhost"),
@@ -133,6 +136,9 @@ public abstract class AbstractAws2SqsTracingTest extends AbstractAws2SqsBaseTest
                                     equalTo(RPC_METHOD, "ReceiveMessage"),
                                     equalTo(HTTP_REQUEST_METHOD, "POST"),
                                     equalTo(HTTP_RESPONSE_STATUS_CODE, 200),
+                                    equalTo(
+                                        stringKey("aws.auth.account.access_key"), "my-access-key"),
+                                    equalTo(stringKey("aws.auth.region"), "ap-northeast-1"),
                                     satisfies(
                                         URL_FULL, v -> v.startsWith("http://localhost:" + sqsPort)),
                                     equalTo(SERVER_ADDRESS, "localhost"),
diff --git a/version.gradle.kts b/version.gradle.kts
index a1cae43b4b..c1520e9947 100644
--- a/version.gradle.kts
+++ b/version.gradle.kts
@@ -1,5 +1,5 @@
-val stableVersion = "2.11.0"
-val alphaVersion = "2.11.0-alpha"
+val stableVersion = "2.11.0-adot1"
+val alphaVersion = "2.11.0-adot1-alpha"
 
 allprojects {
   if (findProperty("otel.stable") != "true") {
